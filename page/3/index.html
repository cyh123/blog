<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"cyh123.github.io","root":"/blog/","images":"/blog/images","scheme":"Mist","darkmode":true,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="yunhai.chen的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="记录每一次进步">
<meta property="og:url" content="https://cyh123.github.io/blog/page/3/index.html">
<meta property="og:site_name" content="记录每一次进步">
<meta property="og:description" content="yunhai.chen的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yunhai.chen">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://cyh123.github.io/blog/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>记录每一次进步</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>




  <script src="/blog/js/third-party/fancybox.js" defer></script>



  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"jtQLIeV6jE3JEz552dDc8drD-gzGzoHsz","app_key":"ntTvuVT0T22Vn198alyrXuKA","security":true,"betterPerformance":false}</script>
  <script src="/blog/js/third-party/statistics/lean-analytics.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">记录每一次进步</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">工作生活中的每一次坑，都是程序员的一块勋章</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li><li class="menu-item menu-item-关于"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-标签"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-分类"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-归档"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yunhai.chen"
      src="/blog/images/me.jpg">
  <p class="site-author-name" itemprop="name">yunhai.chen</p>
  <div class="site-description" itemprop="description">yunhai.chen的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cyh123" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cyh123" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/9581306/yunhai" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;9581306&#x2F;yunhai" rel="noopener me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://cyh123.github.io/blog/2018/04/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/me.jpg">
      <meta itemprop="name" content="yunhai.chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录每一次进步">
      <meta itemprop="description" content="yunhai.chen的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 记录每一次进步">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/04/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">同步容器与并发容器类简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-26 20:28:58" itemprop="dateCreated datePublished" datetime="2018-04-26T20:28:58+00:00">2018-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">java并发编程</span></a>
        </span>
    </span>

  
    <span id="/blog/2018/04/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%AE%80%E4%BB%8B/" class="post-meta-item leancloud_visitors" data-flag-title="同步容器与并发容器类简介" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Valine：</span>
  
    <a title="valine" href="/blog/2018/04/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%AE%80%E4%BB%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/blog/2018/04/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%AE%80%E4%BB%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h1><p>同步容器类包括Vector和HashTable，二者都是早期JDK的一部分，此外还包括在JDK1.2当中添加的一些功能相似的类，这些同步的封装类是由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次都只有一个线程能够访问容器的状态。相较于并行容器，同步容器的实现原理其实很简单，就是对普通容器做了一层封装，并实现容器的每一个方法，在方法上实现同步。比如通过Collections类的工厂方法将一个普通的List封装成一个同步容器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) :</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SynchronizedList</span>&lt;&gt;(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他包装函数<br><img src="/blog/2018/04/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%AE%80%E4%BB%8B/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E5%8C%85%E8%A3%85%E5%87%BD%E6%95%B0.PNG" alt="同步容器包装函数"></p>
<h2 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h2><p>在并发编程当中，虽然同步容器类是线程安全的，但是在某些情况下可能需要额外的客户端加锁来保护复合操作。如下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getLast</span><span class="params">(Vector list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteLast</span><span class="params">(Vector list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> list.size() - <span class="number">1</span>;</span><br><span class="line">    list.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述两个函数中，虽然Vector是线程安全的，但是获取Vector大小与获取&#x2F;删除之间没有锁保护，当获得Vector大笑之后，如另外一个线程删除了Vector中的最末尾位置的元素，则每个函数的最后一句代码执行将报错。因此，对于复合操作，需要在符合操作上用锁来保证操作的原子性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getLast</span><span class="params">(Vector list)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteLast</span><span class="params">(Vector list)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> list.size() - <span class="number">1</span>;</span><br><span class="line">        list.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前的文章<a href="./../../01/Java%E9%9B%86%E5%90%88ArrayList%E4%B8%ADmodCount%E8%AF%A6%E8%A7%A3%E5%8F%8AsubList%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9/#more">《Java集合ArrayList中modCount详解及subList函数要点》</a>中，曾经提到过<code>ConcurrentModificationException</code>异常,在对集合进行迭代操作的过程中，如果修改了原集合，将导致异常的发生。同样，如果在迭代期间modCount被其他线程修改，那么同样将发生<code>ConcurrentModificationException</code>异常。由于使用同步类容器需要保证在对容器进行复合操作及其他一些操作要进行客户端加锁，导致了实现线程安全的同步操作的保障将分散代码的各个地方，这将增加代码实现的难度以及维护的难度。正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略以及简化维护工作。因此，更能实现该目的的并行容器，也就成了更好的选择。</p>
<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>同步容器类存在两个问题，一个问题就是上面提到的复合操作需要客户端加锁，以保证操作的正确性。另外一个就是同步容器将所有对容器状态的访问都串行化，以实现他们的线程安全性，但这种方法的代价是严重降低并发性，当多个线程竞争访问容器的锁时，吞吐量将严重降低。因此，通过并发容器代替同步容器，可以极大地提高伸缩性并降低风险。并发容器注重以下特性：</p>
<ol>
<li>根据具体场景进行设计，尽量避免使用锁，提高容器的并发访问性。</li>
<li>并发容器定义了一些线程安全的复合操作。</li>
<li>并发容器在迭代时，可以不封闭在synchronized中。但是未必每次看到的都是”最新的、当前的”数据。如果说将迭代操作包装在synchronized中，可以达到”串行”的并发安全性，那么并发容器的迭代达到了”脏读”。</li>
</ol>
<p>可以通过下图简单了解concurrent中关于容器类的接口和类：<br><img src="/blog/2018/04/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%AE%80%E4%BB%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="并发容器继承关系"></p>
<h2 id="两个接口"><a href="#两个接口" class="headerlink" title="两个接口"></a>两个接口</h2><ul>
<li><p>ConcurrentMap<br>该接口定义Map的原子操作：putIfAbsent、remove、replace</p>
</li>
<li><p>BlockingQueue<br>阻塞队列，不允许null值；<br>取元素时，如果队列为空则等待；存元素时，如果没有空间则等待；</p>
</li>
</ul>
<p>阻塞队列的方法有四种形式–当操作不能立即得到满足，但可能在未来某一时刻被满足的时候，有四种不同的方式来处理：</p>
<ul>
<li>抛出异常</li>
<li>返回特殊的值（null或false，取决与具体的操作）</li>
<li>无期限地阻塞当前线程，直到该操作成功</li>
<li>仅在指定的最大时长内阻塞，过后还不成功就放弃</li>
</ul>
<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><p>通过上面的图可以知道，concurrent包中的并发容器主要可以四类，分别是：</p>
<ul>
<li>CopyOnWrite容器：CopyOnWriteArrayList、CopyOnWriteArraySet</li>
<li>CocurrentMap的实现类：ConcurrentHashMap、ConcurrentSkipListMap</li>
<li>阻塞队列的实现类（共七种）</li>
<li>其他：ConcurrentLinkedQueue、ConcurrentLikedDeque、ConcurrentSkipListSet</li>
</ul>
<h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h3><p>其实现原理是，在创建CopyOnWrite容器实例时，是通过安全方式发布了一个事实不可变对象，由前一篇文章中我们知道，安全发布的事实不可变对象是线程安全的，那么在访问该对象时就不再需要进一步的同步。但是在每次修改时，都会创建并重新发布一个新的容器副本就行修改，从而实现可变性。需要注意的时，每当修改容器是都会复制底层数组，这需要一定的开销，特别是当容器的规模较大时。所以，建议仅当迭代操作远远多余修改操作时，才应该使用“写入时复制”容器。</p>
<h4 id="CopyOnWriteArrayList（写入时复制List）"><a href="#CopyOnWriteArrayList（写入时复制List）" class="headerlink" title="CopyOnWriteArrayList（写入时复制List）"></a>CopyOnWriteArrayList（写入时复制List）</h4><p>CopyOnWriteArrayList用于替代同步List，其在迭代期间不需要对容器进行加锁或复制。</p>
<h4 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h4><p>java.util.ArrayList的线程安全版本：所有的修改操作都是通过对底层数组的最新copy来实现。</p>
<h3 id="ConcurrentMap的实现类"><a href="#ConcurrentMap的实现类" class="headerlink" title="ConcurrentMap的实现类"></a>ConcurrentMap的实现类</h3><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>与HashMap一样，ConcurrentHashMap也是一个基于散列的Map，但它使用一种完全不同的加锁策略来提供更高的并发性和伸缩性。ConcurrentHashMap并部署在每个方法上都用同一个锁进行同步并使得只能有一个线程访问容器，而是使用一种粒度更细的锁机制来实现更大程度的共享，这种机制成为分段锁。<code>在这种机制中，任意数量的读取线程可以并发地访问Map，执行读取操作的线程和执行写入操作的线程可以并发地访问Map，并且一定数量的写入线程可以并发地修改Map。</code>，所谓分段锁，简单来说就是将数据进行分段，每一段锁用于锁容器中的一部分数据，那么当多线程访问容器里的不容数据段的数据时，线程间就不会存在锁竞争，从而可以有效地提高并发访问效率。有些方法需要跨段，比如size()，就需要按照顺序锁定所有的段，完成操作后，再按顺序释放锁。有关分段锁的应用，可以参看<a href="https://www.cnblogs.com/ITtangtang/p/3948786.html">ConcurrentHashMap分段锁技术</a>。</p>
<h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><p>ConcurrentSkipListMap在JDK并发工具类使用范围不是很广，它是针对某一特殊需求而设计的——支持排序，同时支持搜索目标返回最接近匹配项的导航方法。ConcurrentSkipListMap使用SkipList(跳表)实现排序，而TreeMap使用红黑树。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列是一个支持阻塞插入和阻塞移除的队列：当队列满时，队列会阻塞插入元素的线程，直到队列不满；当队列为空时，队列会阻塞获取元素的线程，直到队列不空。阻塞队列常用于生产者和消费者模式，生产者向队列中添加元素，消费者则从队列中取出元素。线程池当中使用阻塞队列来实现任务的排队，在这里简单介绍一下阻塞队列的几个具体实现类。</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>使用数组实现的有界阻塞队列，按照FIFO的原则对元素排序；内部使用重入锁可实现公平访问。内部使用一个重入锁来控制并发修改操作，即同一时刻，只能进行放或取中的一个操作。初始化时，必须指定容量大小。</p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>使用链表实现的有界阻塞队列，按照FIFO的原则对元素排序；默认和最大长度均为Integer.MAX_VALUE，所以在使用的时候，要注意指定最大容量，否则可能会导致元素数量过多，内存溢出。内部使用两个重入锁来控制并发操作，即同一时刻，允许同时进行放和取。</p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>支持优先级的无界阻塞队列，默认情况下元素按照自然顺序升序排列，可以自定义类实现compareTo()方法来指定元素的排序规则，或在初始化PriorityBlockingQueue时指定构造参数Comparator来对元素进行排序，但不能保证同优先级元素的顺序；</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>支持延时获取元素的无界阻塞队列，队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有在延迟期满后，才能从队列中获取元素。<br>DelayQueue可以应用在缓存系统的设计（用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素，表示缓存有效期到了）、定时任务调度等场景（ScheduledThreadPoolExecutor中的ScheduledFutureTask类就是实现的Delayed接口）</p>
<h4 id="SyncronousQueue"><a href="#SyncronousQueue" class="headerlink" title="SyncronousQueue"></a>SyncronousQueue</h4><p>不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素，支持公平访问队列，非常适合传递性场景，即把生产者线程处理的数据直接传递给消费者线程，队列本身不存储任何元素。SyncronousQueue的吞吐量高于ArrayBlockingQueue和LinkedBlockingDeque。</p>
<h4 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h4><p>使用链表实现的无界阻塞TransferQueue，当有消费者正在等待接受元素时，队列可以通过transfer()方法把生产者传入的元素立即传给消费者。</p>
<h4 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h4><p>使用链表实现的双向阻塞队列，可以在队列的两端进行插入和移除元素。</p>
<h3 id="其他-等补充"><a href="#其他-等补充" class="headerlink" title="其他(等补充)"></a>其他(等补充)</h3><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因此，在使用容器进行开发时，我们有三种选择，第一种是使用普通的容器，二是使用同步容器，三是使用并发容器。在容器的选择上，还是需要我们根据具体的业务需要，选择合适的容器来实现业务功能。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://cyh123.github.io/blog/2018/04/23/Groovy%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/me.jpg">
      <meta itemprop="name" content="yunhai.chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录每一次进步">
      <meta itemprop="description" content="yunhai.chen的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 记录每一次进步">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/04/23/Groovy%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Groovy学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-23 20:22:56" itemprop="dateCreated datePublished" datetime="2018-04-23T20:22:56+00:00">2018-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/groovy/" itemprop="url" rel="index"><span itemprop="name">groovy</span></a>
        </span>
    </span>

  
    <span id="/blog/2018/04/23/Groovy%E5%AD%A6%E4%B9%A0/" class="post-meta-item leancloud_visitors" data-flag-title="Groovy学习" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Valine：</span>
  
    <a title="valine" href="/blog/2018/04/23/Groovy%E5%AD%A6%E4%B9%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/blog/2018/04/23/Groovy%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <div class="show-content">
          <p>学习自：<a href="http://www.infoq.com/cn/articles/android-in-depth-gradle" target="_blank">http://www.infoq.com/cn/articles/android-in-depth-gradle</a> （大部分可能有差不多，只有少部分改了纰漏和认为他写的不对的地方）</p>
<h2>安装(mac)</h2>
<pre><code>brew install groovy</code></pre>
<p>查看版本号</p>
<pre><code>groovy -verson</code></pre>
<p>环境</p>
<pre><code>Android studio 2.0</code></pre>
<h2>基础</h2>
<ul>
<li>Groovy注释标记和Java一样，支持//或者//</li>
<li>Groovy语句可以不用分号结尾。Groovy为了尽量减少代码的输入，确实煞费苦心</li>
<li>Groovy中支持动态类型，即定义变量的时候可以不指定其类型。Groovy中，变量定义可以使用关键字def。注意，虽然def不是必须的，但是为了代码清晰，建议还是使用def关键字</li>
</ul>
<pre><code>def var =1 
def str= "i am a person"
def int x = 1//也可以指定类型</code></pre>
<ul>
<li>函数定义时，参数的类型也可以不指定。比如</li>
</ul>
<pre><code>String function(arg1,args2)&#123;//无需指定参数类型
&#125;</code></pre>
<ul>
<li>除了变量定义可以不指定类型外，Groovy中函数的返回值也可以是无类型的。比如：<br>//无类型的函数定义，必须使用def关键字</li>
</ul>
<pre><code>def  nonReturnTypeFunc()&#123;
     last_line   //最后一行代码的执行结果就是本函数的返回值
&#125;
//如果指定了函数返回类型，则可不必加def关键字来定义函数
String  getString()&#123;
   return "I am a string"
&#125;</code></pre>
<p>其实，所谓的无返回类型的函数，我估计内部都是按返回Object类型来处理的。毕竟，Groovy是基于Java的，而且最终会转成Java Code运行在JVM上</p>
<ul>
<li>函数返回值：Groovy的函数里，可以不使用return xxx来设置xxx为函数返回值。如果不使用return语句的话，则函数里最后一句代码的执行结果被设置成返回值。比如</li>
</ul>
<pre><code>//下面这个函数的返回值是字符串"getSomething return value"
def getSomething()&#123;
   "getSomething return value" //如果这是最后一行代码，则返回类型为String
    1000 //如果这是最后一行代码，则返回类型为Integer
&#125;</code></pre>
<p>注意，如果函数定义时候指明了返回值类型的话，函数中则必须返回正确的数据类型，否则运行时报错。如果使用了动态类型的话，你就可以返回任何类型了。</p>
<ul>
<li>
<p>Groovy对字符串支持相当强大，充分吸收了一些脚本语言的优点：<br>1  单引号''中的内容严格对应Java中的String，不对$符号进行转义</p>
<pre><code>def singleQuote='I am $ dolloar'  //输出就是I am $ dolloar</code></pre>
<p>2  双引号""的内容则和脚本语言的处理有点像，如果字符中有$号的话，则它会<strong>$表达式</strong>先求值。</p>
<pre><code>def doubleQuoteWithoutDollar = "I am one dollar" //输出 I am one dollar
def x = 1
def doubleQuoteWithDollar = "I am $x dolloar" //输出I am 1 dolloar</code></pre>
<p>3 三个引号'''xxx'''中的字符串支持随意换行 比如</p>
<pre><code>def multieLines = ''' begin
   line  1 
   line  2
   end '''</code></pre>
</li>
<li>
<p>最后，除了每行代码不用加分号外，Groovy中函数调用的时候还可以不加括号。比如：</p>
<pre><code>println("test") ---&gt; println "test"</code></pre>
</li>
</ul>
<p><strong>注意，虽然写代码的时候，对于函数调用可以不带括号，但是Groovy经常把属性和函数调用混淆。比如</strong></p>
<pre><code>def getSomething()&#123;
   "hello"
&#125;</code></pre>
<p>getSomething()   //如果不加括号的话，Groovy会误认为getSomething是一个变量。<br>所以，调用函数要不要带括号，我个人意见是如果这个函数是Groovy API或者Gradle API中比较常用的，比如println，就可以不带括号。否则还是带括号。Groovy自己也没有太好的办法解决这个问题，只能<strong>兵来将挡水来土掩</strong>了。</p>
<h2>数据类型</h2>
<p>Groovy中的数据类型我们就介绍两种和Java不太一样的：</p>
<ul>
<li>一个是Java中的基本数据类型。</li>
<li>另外一个是Groovy中的容器类。</li>
<li>最后一个非常重要的是闭包。</li>
</ul>
<p><strong>基本数据类型</strong><br>作为动态语言，Groovy世界中的所有事物都是对象。所以，<strong>int，boolean这些Java中的基本数据类型，在Groovy代码中其实对应的是它们的包装数据类型。比如int对应为Integer，boolean对应为Boolean。</strong>比如下图中的代码执行结果：</p>
<div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-2cebe00aa7e0f455.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-2cebe00aa7e0f455.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image005.png</div>
</div>
<p><strong>容器类</strong><br> List类</p>
<pre><code>变量定义：List变量由[]定义，比如

<p>def aList &#x3D; [5,’string’,true] &#x2F;&#x2F;List由[]定义，其元素可以是任何对象</p>
<p>变量存取：可以直接通过索引存取，而且不用担心索引越界。如果索引超过当前链表长度，List会自动<br>往该索引添加元素</p>
<p>assert aList[1] &#x3D;&#x3D; ‘string’<br>assert aList[5] &#x3D;&#x3D; null &#x2F;&#x2F;第6个元素为空<br>aList[100] &#x3D; 100  &#x2F;&#x2F;设置第101个元素的值为10<br>assert aList[100] &#x3D;&#x3D; 100</p>
<p>那么，aList到现在为止有多少个元素呢？</p>
<p>println aList.size  &#x3D;&#x3D;&#x3D;&gt;结果是101</code></pre></p>
<p> Map类</p>
<pre><code>容器变量定义

<p>变量定义：Map变量由[:]定义，比如</p>
<p>def aMap &#x3D; [‘key1’:’value1’,’key2’:true] </p>
<p>Map由[:]定义，注意其中的冒号。冒号左边是key，右边是Value。key必须是字符串，value可以是任何对象。另外，key可以用’’或””包起来，也可以不用引号包起来。比如</p>
<p>def aNewMap &#x3D; [key1:”value”,key2:true] &#x2F;&#x2F;其中的key1和key2默认被<br>处理成字符串”key1”和”key2”</p>
<p>不过Key要是不使用引号包起来的话，也会带来一定混淆，比如</p>
<p>def key1&#x3D;”wowo”<br>def aConfusedMap&#x3D;[key1:”who am i?”]</p>
<p>aConfuseMap中的key1到底是”key1”还是变量key1的值“wowo”？显然，答案是字符串”key1”。如果要是”wowo”的话，则aConfusedMap的定义必须设置成：</p>
<p>def aConfusedMap&#x3D;[(key1):”who am i?”]</p>
<p>Map中元素的存取更加方便，它支持多种方法：</p>
<p>println aMap.keyName    &lt;&#x3D;&#x3D;这种表达方法好像key就是aMap的一个成员变量一样<br>println aMap[‘keyName’] &lt;&#x3D;&#x3D;这种表达方法更传统一点<br>aMap.anotherkey &#x3D; “i am map”  &lt;&#x3D;&#x3D;为map添加新元素</code></pre></p>
<p>Range类<br>Range是Groovy对List的一种拓展，变量定义和大体的使用方法如下：</p>
<pre><code>def aRange = 1..5  &lt;==Range类型的变量 由begin值+两个点+end值表示
                      左边这个aRange包含1,2,3,4,5这5个值

<p>如果不想包含最后一个元素，则</p>
<p>def aRangeWithoutEnd &#x3D; 1..&lt;5  &lt;&#x3D;&#x3D;包含1,2,3,4这4个元素<br>println aRange.from<br>println aRange.to</code></pre></p>
<p>API<br>Groovy的API文档位于 <a href="http://www.groovy-lang.org/api.html" target="_blank">http://www.groovy-lang.org/api.html</a></p>
<p><strong>闭包</strong><br>闭包，英文叫Closure，是Groovy中非常重要的一个数据类型或者说一种概念了。闭包的历史来源，种种好处我就不说了。我们直接看怎么使用它！</p>
<p>闭包，是一种数据类型，它代表了一段可执行的代码。其外形如下：</p>
<pre><code>def aClosure = &#123;//闭包是一段代码，所以需要用花括号括起来..  
    String param1, int param2 -&gt;  //这个箭头很关键。箭头前面是参数定义，箭头后面是代码  
    println"this is code" //这是代码，最后一句是返回值，  
   //也可以使用return，和Groovy中普通函数一样  
&#125;</code></pre>
<p>简而言之，Closure的定义格式是：</p>
<pre><code>def xxx = &#123;paramters -&gt; code&#125;  //或者  
def xxx = &#123;无参数，纯code&#125;  这种case不需要-&gt;符号</code></pre>
<p><strong>说实话，从C/C++语言的角度看，闭包和函数指针很像</strong>。闭包定义好后，要调用它的方法就是：<br>闭包对象.call(参数)  或者更像函数指针调用的方法：<br>闭包对象(参数)<br>比如</p>
<pre><code>aClosure.call("this is string",100)  或者  
aClosure("this is string", 100)</code></pre>
<p>上面就是一个闭包的定义和使用。在闭包中，还需要注意一点：<br><strong>如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。</strong><br>比如：</p>
<pre><code>def greeting = &#123; "Hello, $it!" &#125;
assert greeting('Patrick') == 'Hello, Patrick!'</code></pre>
<p>等同于</p>
<pre><code>def greeting = &#123; it -&gt; "Hello, $it!" &#125;
assert greeting('Patrick') == 'Hello, Patrick!'</code></pre>
<p>但是，如果在闭包定义时，采用下面这种写法，则表示闭包没有参数！</p>
<pre><code>def noParamClosure = &#123; -&gt; true &#125;</code></pre>
<p>这个时候，我们就不能给noParamClosure传参数了！</p>
<pre><code>noParamClosure ("test")  &lt;==报错喔！</code></pre>
<p><strong>Closure使用中的注意点</strong></p>
<ol>
<li>省略圆括号</li>
</ol>
<p>闭包在Groovy中大量使用，比如很多类都定义了一些函数，这些函数最后一个参数都是一个闭包。比如：</p>
<pre><code>public static &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt; self, Closure closure)</code></pre>
<p>上面这个函数表示针对List的每一个元素都会调用closure做一些处理。这里的closure，就有点回调函数的感觉。但是，在使用这个each函数的时候，我们传递一个怎样的Closure进去呢？比如：</p>
<pre><code>def iamList = [1,2,3,4,5]  //定义一个List
iamList.each&#123;  //调用它的each，这段代码的格式看不懂了吧？each是个函数，圆括号去哪了？
      println it
&#125;</code></pre>
<p>上面代码有两个知识点：<br><strong>each函数调用的圆括号不见了</strong>！原来，Groovy中，当函数的最后一个参数是闭包的话，可以省略圆括号。比如</p>
<pre><code>def  testClosure(int a1,String b1, Closure closure)&#123;
      //do something
      closure() //调用闭包
&#125;
那么调用的时候，就可以免括号！
testClosure (4, "test", &#123;
   println "i am in closure"
&#125; )  //红色的括号可以不写..</code></pre>
<p>注意，这个特点非常关键，因为以后在Gradle中经常会出现图7这样的代码：</p>
<div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-35123fc8b1966861.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-35123fc8b1966861.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image008.png</div>
</div>
<p>经常碰见图7这样的没有圆括号的代码。省略圆括号虽然使得代码简洁，看起来更像脚本语言，但是它这经常会让我confuse（不知道其他人是否有同感），以doLast为例，完整的代码应该按下面这种写法：</p>
<pre><code> doLast(&#123;
   println 'Hello world!'
&#125;)</code></pre>
<p>有了圆括号，你会知道 doLast只是把一个Closure对象传了进去。很明显，它不代表这段脚本解析到doLast的时候就会调用println 'Hello world!' 。</p>
<p>但是把圆括号去掉后，就感觉好像println 'Hello world!'立即就会被调用一样！</p>
<ol>
<li>如何确定Closure的参数</li>
</ol>
<p>另外一个比较让人头疼的地方是，Closure的参数该怎么搞？还是刚才的each函数：</p>
<pre><code>public static &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt; self, Closure closure)</code></pre>
<p>如何使用它呢？比如：</p>
<pre><code>def iamList = [1,2,3,4,5]  //定义一个List变量
iamList.each&#123;  //调用它的each函数，只要传入一个Closure就可以了。
  println it
&#125;</code></pre>
<p>看起来很轻松，其实：<br><strong>对于each所需要的Closure，它的参数是什么？有多少个参数？返回值是什么？</strong></p>
<p>我们能写成下面这样吗？</p>
<pre><code>iamList.each&#123;String name,int x -&gt;
  return x
&#125;  //运行的时候肯定报错！</code></pre>
<p>所以，Closure虽然很方便，但是它一定会和使用它的上下文有极强的关联。要不，作为类似回调这样的东西，我如何知道调用者传递什么参数给Closure呢？</p>
<p>此问题如何破解？只能通过查询API文档才能了解上下文语义。比如下图8：<br></p><div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-8f67a60278c33486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-8f67a60278c33486.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image009.png</div>
</div><div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-6910a1e19ae2a3af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-6910a1e19ae2a3af.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image010.png</div>
</div>
<p>图8中：<br>each函数说明中，将给指定的closure传递Set中的每一个item。所以，closure的参数只有一个。<br>findAll中，<strong>绝对抓瞎</strong>了。一个是没说明往Closure里传什么。另外没说明Closure的返回值是什么.....。</p>
<p><strong>对Map的findAll而言，Closure可以有两个参数。findAll会将Key和Value分别传进去。并且，Closure返回true，表示该元素是自己想要的。返回false表示该元素不是自己要找的</strong>。示意代码所示：</p>
<pre><code>def result = aMap.findAll &#123;
    key, value -&gt;
        println "key=$key,value=$value"
        if (key == "k1")
            return true
        return false
&#125;</code></pre>
<p>Closure的使用有点坑，很大程度上依赖于你对API的熟悉程度，所以最初阶段，SDK查询是少不了的。</p>
<h2>脚本类</h2>
<p><strong>import</strong><br>groovy也可以像java那样写package，然后写类</p>
<pre><code>package bean
class Person &#123;
    String name
    String gender
    Person(name, gender) &#123;
        this.name = name
        this.gender = gender
    &#125;
    def print() &#123;
        println name + " " + gender
    &#125;
&#125;</code></pre>
<pre><code>import bean.Person
def name = 'EvilsoulM'
def person=new Person(name,"male");
person.print()</code></pre>
<p>groovy和Java类很相似。当然，如果不声明public/private等访问权限的话，Groovy中类及其变量默认都是public的。</p>
<p><strong>脚本到底是什么</strong><br>Java中，我们最熟悉的是类。但是我们在Java的一个源码文件中，不能不写class（interface或者其他....），而Groovy可以像写脚本一样，把要做的事情都写在xxx.groovy中，而且可以通过groovy xxx.groovy直接执行这个脚本。这到底是怎么搞的？</p>
<p>Groovy把它转换成这样的Java类：<br>执行<strong> groovyc</strong> -d classes test.groovy<br><strong>groovyc</strong>是groovy<br>的编译命令，-d classes用于将编译得到的class文件拷贝到classes文件夹下<br>图13是test.groovy脚本转换得到的java class。用jd-gui反编译它的代码：<br></p><div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-c8b8b60c9e14e166.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-c8b8b60c9e14e166.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image015.png</div>
</div>
<ul>
<li>test.groovy被转换成了一个test类，它从script派生。</li>
<li>每一个脚本都会生成一个static main函数。这样，当我们groovy test.groovy的时候，其实就是用java去执行这个main函数</li>
<li>
<strong>脚本中的所有代码都会放到run函数中</strong>。比如，println 'Groovy world'，这句代码实际上是包含在run函数里的。</li>
<li>如果脚本中定义了函数，则函数会被定义在test类中。</li>
</ul>
<p><strong>groovyc</strong>是一个比较好的命令，读者要掌握它的用法。然后利用jd-gui来查看对应class的Java源码。</p>
<p><strong>3.脚本中的变量和作用域</strong><br>前面说了，xxx.groovy只要不是和Java那样的class，那么它就是一个脚本。而且脚本的代码其实都会被放到run函数中去执行。那么，在Groovy的脚本中，很重要的一点就是脚本中定义的<strong>变量和它的作用域</strong>。举例：</p>
<pre><code>def x = 1 &lt;==注意，这个x有def（或者指明类型，比如 int x = 1）  
def printx()&#123;  
   println x  
&#125;</code></pre>
<p>printx()  &lt;==报错，说x找不到</p>
<p>为什么？继续来看反编译后的class文件。</p>
<div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-80de7afa052a7329.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-80de7afa052a7329.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image016.png</div>
</div><p><br> 图中，x也没有被定义成test的成员函数，而是在run的执行过程中，将x作为一个属性添加到test实例对象中了。然后在printx中，先获取这个属性。</p>
<p>注意，Groovy的文档说 x = 1这种定义将使得x变成test的成员变量，但从反编译情况看，这是不对的.....(这是infoQ文章中说的，但是测试来说这句话是对的，应该是文章作者没有定义成class)</p>
<p>虽然printx可以访问x变量了，但是假如有其他脚本却无法访问x变量。因为它不是test的成员变量。</p>
<p>比如，我在测试目录下创建一个新的名为test1.groovy。这个test1将访问test.groovy中定义的printx函数：</p>
<pre><code>def atest=new test()
atest.printx()</code></pre>
<p>这种方法使得我们可以将代码分成模块来编写，<strong>比如将公共的功能放到test.groovy中，然后使用公共功能的代码放到test1.groovy中</strong>。<br>执行groovy test1.groovy，报错。说x找不到。这是因为x是在test的run函数动态加进去的。怎么办？</p>
<pre><code>import groovy.transform.Field;   //必须要先import
@Field x = 1  &lt;==在x前面加上@Field标注，这样，x就彻彻底底是test的成员变量了。</code></pre>
<p>查看编译后的test.class文件，得到：</p>
<div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-983bf79cb93f1085.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-983bf79cb93f1085.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image019.png</div>
</div><p><br>这个时候，test.groovy中的x就成了test类的成员函数了。如此，我们可以在script中定义那些需要输出给外部脚本或类使用的变量了！</p>
<p>eg:<br>ScriptBase.groovy类 (用了filed 就相当这就是一个class 就不用再自己定义class了)</p>
<pre><code>import groovy.transform.Field;
@Field author = 'EvilsouM'
@Field gender = 'male'
@Field age = 25
//必须要先import
def printInfo() &#123;
    println "name-&gt;$author  gender-&gt;$gender age-&gt;$age"
&#125;</code></pre>
<p>或者自己定义class</p>
<pre><code>class ScriptBase &#123;
    def author = 'EvilsouM'
    def gender = 'male'
    def age = 25//必须要先import
    def printInfo() &#123;
        println "name-&gt;$author  gender-&gt;$gender age-&gt;$age"
    &#125;
&#125;</code></pre>
<p>scripttest.groovy类</p>
<pre><code>def Closure printAuthorInfo = &#123;
            String name, String gender, int age -&gt;
                println "name-&gt;$name  gender-&gt;$gender age-&gt;$age"
&#125;
def ScriptBase base = new ScriptBase()
base.printInfo()
printAuthorInfo.call(base.author, base.gender, base.age) 上面两种方式都能拿到成员变量</code></pre>
<p><strong>文件I/O操作</strong><br>本节介绍下Groovy的文件I/O操作。直接来看例子吧，虽然比Java看起来简单，但要理解起来其实比较难。尤其是当你要自己查SDK并编写代码的时候。</p>
<p>整体说来，Groovy的I/O操作是在原有Java I/O操作上进行了更为简单方便的封装，并且使用Closure来简化代码编写。主要封装了如下一些了类：</p>
<div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-712c42d8fcdac92b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-712c42d8fcdac92b.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image020.png</div>
</div>
<ul>
<li>读文件<br>Groovy中，文件读操作简单到令人发指：<br>def targetFile = new File(文件名)  &lt;==File对象还是要创建的。<br>然后打开<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" target="_blank">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html</a><br>看看Groovy定义的API：</li>
</ul>
<p>1 读该文件中的每一行：eachLine的唯一参数是一个Closure。Closure的参数是文件每一行的内容<br>   其内部实现肯定是Groovy打开这个文件，然后读取文件的一行，然后调用Closure...</p>
<pre><code>def File targetFile = new File("build.gradle")
targetFile.eachLine &#123;
    String line -&gt;
        println line
&#125;</code></pre>
<p>2 直接得到文件内容</p>
<pre><code>targetFile.getBytes()  &lt;==文件内容一次性读出，返回类型为byte[]</code></pre>
<p>3 使用InputStream.InputStream的SDK在 <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" target="_blank">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html</a></p>
<pre><code>def ism =  targetFile.newInputStream()  
//操作ism，最后记得关掉  
ism.close</code></pre>
<p>4 使用闭包操作inputStream，以后在Gradle里会常看到这种搞法</p>
<pre><code> targetFile.withInputStream&#123;
 ism -&gt; 操作ism. 不用close。Groovy会自动替你close
&#125;</code></pre>
<ol>
<li>写文件<br>和读文件差不多。不再啰嗦。这里给个例子，告诉大家如何copy文件。<pre><code class="groovy">def srcFile = new File(源文件名)
def targetFile = new File(目标文件名)
targetFile.withOutputStream&#123;
os-&gt; srcFile.withInputStream &#123;
ins-&gt;
   os &lt;&lt; ins //利用OutputStream的&lt;&lt;操作符重载，完成从inputstream到OutputStream  //的输出
  &#125;
&#125;</code></pre>
</li>
</ol>

<pre><code>    &lt;/div&gt;
    &lt;!--  --&gt;

    &lt;div class=&quot;show-foot&quot;&gt;
      &lt;a class=&quot;notebook&quot; href=&quot;/nb/2655670&quot;&gt;
        &lt;i class=&quot;iconfont ic-search-notebook&quot;&gt;&lt;/i&gt; &lt;span&gt;其他&lt;/span&gt;
</code></pre>
<p></a>          <div class="copyright" data-toggle="tooltip" data-html="true" data-original-title="转载请联系作者获得授权，并标注“简书作者”。"><br>          </div></p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://cyh123.github.io/blog/2018/04/17/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/me.jpg">
      <meta itemprop="name" content="yunhai.chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录每一次进步">
      <meta itemprop="description" content="yunhai.chen的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 记录每一次进步">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/04/17/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/" class="post-title-link" itemprop="url">java并发编程实现线程安全性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-17 14:21:32" itemprop="dateCreated datePublished" datetime="2018-04-17T14:21:32+00:00">2018-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">java并发编程</span></a>
        </span>
    </span>

  
    <span id="/blog/2018/04/17/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/" class="post-meta-item leancloud_visitors" data-flag-title="java并发编程实现线程安全性" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Valine：</span>
  
    <a title="valine" href="/blog/2018/04/17/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/blog/2018/04/17/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三中方式可以修复这个问题：</p>
<ol>
<li><p>不在线程之间共享该状态变量</br><br>采用线程封闭技术，实现状态变量不在线程之间进行共享。线程封闭技术有三个实现原理：</br></p>
</li>
<li><p>Ad-hoc线程封闭</br><br>其实就是维护线程封闭性的职责完全由程序实现来承担，该方式的线程封闭是非常脆弱的</br></p>
</li>
<li><p>栈封闭</br><br>在栈封闭中。只能通过局部变量才能访问对象，局部变量的固有属性之一就是封闭在执行环境当中，它们位于执行线程的栈中，其他线程无法访问这个栈。</br>该方法其实也就是使用局部变量来实现线程的安全。</br></p>
</li>
<li><p>ThreadLocal类</br><br>维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口和方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是能返回当前执行线程在调用set时设置的最新值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;() &#123;</span><br><span class="line">    pulic Connection <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHoler.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将状态变量修改为不可变的变量</br><br><code>不可比对象一定是线程安全的</code>。所谓不可变对象，其实就是如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性是不可变对象的固有属性之一。因为不可变对象在创建之后只会有一种状态，不会发生变化，所以一定是线程安全的。要使一个对象成为不可变对象，需要满足以下三个条件：</p>
</li>
</ol>
<ul>
<li>对象创建后其状态就不能修改</li>
<li>对象的所有与都是final类型的</li>
<li>对象被正确地创建了（在对象的创建期间，this引用没有逸出）。</br><br>其中，如果对象从技术上来看是可变的，但其状态在对象被创建后就不会再变化，那么把这种对象成为<code>“事实不可变对象”</code>，这些对象不需要满足上述的三个条件，在这些对象发布之后，程序只需要将它们视作不可变的对象即可。</li>
</ul>
<ol start="3">
<li>在访问状态变量时使用同步</br><br>在大多数情况下，以上两种保证线程安全性的方式不足以满足我们的开发需求，这是，我们就需要在访问共享的状态变量时，使用同步机制，保证线程的安全性。</li>
</ol>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://cyh123.github.io/blog/2018/04/16/Java%E9%9B%86%E5%90%88ArrayList%E4%B8%ADmodCount%E8%AF%A6%E8%A7%A3%E5%8F%8AsubList%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/me.jpg">
      <meta itemprop="name" content="yunhai.chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录每一次进步">
      <meta itemprop="description" content="yunhai.chen的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 记录每一次进步">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/04/16/Java%E9%9B%86%E5%90%88ArrayList%E4%B8%ADmodCount%E8%AF%A6%E8%A7%A3%E5%8F%8AsubList%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9/" class="post-title-link" itemprop="url">Java集合ArrayList中modCount详解及subList函数要点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-16 15:55:27" itemprop="dateCreated datePublished" datetime="2018-04-16T15:55:27+00:00">2018-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">集合</span></a>
        </span>
    </span>

  
    <span id="/blog/2018/04/16/Java%E9%9B%86%E5%90%88ArrayList%E4%B8%ADmodCount%E8%AF%A6%E8%A7%A3%E5%8F%8AsubList%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9/" class="post-meta-item leancloud_visitors" data-flag-title="Java集合ArrayList中modCount详解及subList函数要点" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Valine：</span>
  
    <a title="valine" href="/blog/2018/04/16/Java%E9%9B%86%E5%90%88ArrayList%E4%B8%ADmodCount%E8%AF%A6%E8%A7%A3%E5%8F%8AsubList%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/blog/2018/04/16/Java%E9%9B%86%E5%90%88ArrayList%E4%B8%ADmodCount%E8%AF%A6%E8%A7%A3%E5%8F%8AsubList%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>因为一次在项目开发中使用ArrayList的过程中，发生了<strong>ConcurrentModificationException</strong>异常，于是查询了相关资料，对发生该异常的原因记录一下。</p>
<p>所谓的ConcurrentModificationException翻译过来就是并发修改异常，网上大部分该异常出现的原因，都是在使用迭代器的时候发生的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        // 创建并添加元素</span><br><span class="line">        array.add(&quot;hello&quot;);</span><br><span class="line">        array.add(&quot;world&quot;);</span><br><span class="line">        array.add(&quot;java&quot;);</span><br><span class="line">        Iterator it = array.iterator();</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            String s = (String) it.next();</span><br><span class="line">            if (&quot;world&quot;.equals(s)) &#123;</span><br><span class="line">                array.add(&quot;javaee&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该例子中，我们使用迭代器进行迭代的过程中对集合进行了操作（不限于此处的添加操作，也可能是删除等），导致迭代器失效抛出该异常。但是在项目当中，本人并没有使用到迭代器，而是存在下面一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TableEntity&gt; tableEntities = tableData.getValue().subList(1, tableData.getValue().size());</span><br><span class="line">List&lt;TableEntity&gt; newEntitys = tableData.getValue().subList(0,1);</span><br><span class="line">List&lt;TableEntity&gt; entities = sortTableEntity(tableEntities);</span><br><span class="line">newEntitys.addAll(entities);</span><br><span class="line">tableData.getValue().clear();</span><br><span class="line">tableData.getValue().addAll(newEntitys);</span><br></pre></td></tr></table></figure>
<p>异常在最后一步的时候抛出。可见，ConcurrentModificationException异常不仅仅是在使用迭代器的时候会出现。分析ArrayList类的subList源码我们可以发现，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubList</span>(<span class="built_in">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处返回了一个SubList的对象，而在其构造函数内部，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubList(AbstractList&lt;E&gt; parent,int offset, int fromIndex, int toIndex) &#123;</span><br><span class="line">	this.parent = parent;</span><br><span class="line">	this.parentOffset = fromIndex;</span><br><span class="line">	this.offset = offset + fromIndex;</span><br><span class="line">	this.size = toIndex - fromIndex;</span><br><span class="line">	this.modCount = ArrayList.this.modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<strong>this.modCount &#x3D; ArrayList.this.modCount</strong>这样一句代码。而在第一个迭代器的例子中，通过iterator()函数返回的迭代器在构造当中也使用到了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> &#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.size;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可见，该异常的抛出与modCount有关,modCount属性是从AbstractList抽象类继承而来的。查看javadoc文档中的解释:</p>
<blockquote>
<p>The number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.<br>This field is used by the iterator and list iterator implementation returned by the iterator and listIterator methods. If the value of this field changes unexpectedly, the iterator (or list iterator) will throw a ConcurrentModificationException in response to the next, remove, previous, set or add operations. This provides fail-fast behavior, rather than non-deterministic behavior in the face of concurrent modification during iteration.</p>
</blockquote>
<p>我们知道该参数用来记录集合被修改的次数，之所以要记录修改的次数，是因为ArrayList不是线程安全的，为了防止在使用迭代器和子序列的过程当中对原集合的修改导致迭代器及子序列的失效，故保存了修改次数的记录，在迭代器的操作及子序列的操作过程当中，会首先去检查modCount是否相等（函数checkForComodification()），如果不想等的话，则说明集合被修改了，那么为了防止后续不明确的错误发生，于是便抛出了该异常。为了防止该异常的出现，在使用迭代器进行集合的迭代是，若要对集合进行修改，需要通过迭代器提供的对集合进行操作的函数来进行。而对我代码中出现的问题，可以修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TableEntity&gt; tableEntities = Lists.newArrayList(tableData.getValue().subList(1, tableData.getValue().size()));</span><br><span class="line">List&lt;TableEntity&gt; newEntitys = Lists.newArrayList(tableData.getValue().subList(0,1));</span><br><span class="line">List&lt;TableEntity&gt; entities = sortTableEntity(tableEntities);</span><br><span class="line">newEntitys.addAll(entities);</span><br><span class="line">tableData.getValue().clear();</span><br><span class="line">tableData.getValue().addAll(newEntitys);</span><br></pre></td></tr></table></figure>
<p>这样的话，newEntitys就是一个ArrayList的对象而不是SubList的对象了。该情况也是第一次遇到，网上其他解释基本上都是第一种情况（即使用迭代器）发生。其实无论是第一种情况还是第二种情况，本质都是因为原集合的modCount被修改，导致与SubList的modCount或者是迭代器的expectedModCount不同导致的。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://cyh123.github.io/blog/2018/04/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/me.jpg">
      <meta itemprop="name" content="yunhai.chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录每一次进步">
      <meta itemprop="description" content="yunhai.chen的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 记录每一次进步">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/04/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">java并发编程中的一些基础概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-15 12:53:43" itemprop="dateCreated datePublished" datetime="2018-04-15T12:53:43+00:00">2018-04-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">java并发编程</span></a>
        </span>
    </span>

  
    <span id="/blog/2018/04/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="post-meta-item leancloud_visitors" data-flag-title="java并发编程中的一些基础概念" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Valine：</span>
  
    <a title="valine" href="/blog/2018/04/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/blog/2018/04/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>博主在学习并发编程的过程当中，使用的书籍是<a href="https://book.douban.com/subject/10484692/">《Java并发编程实战》</a>这本书，但阅读下来，只能说本书的内容是很适合学习的，但是不知道是因为原版英语图书本身的写作问题，还是译者的翻译问题，本书的第一部分——基础知识 阅读起来难以理解。书中使用了大量的并发编程领域的专业词汇，由于本书不是很好阅读，这是博主半年后第二次尝试阅读该书，终于理解了书中内容，尤其是第一部分。为了方便后续的学习，在这里先把第一部分的内容梳理一下，对几个重要的关键词汇做一些解释。</p>
<h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p>
<h1 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h1><p>书中在介绍不变性时讲的是不可变对象，但是在书中很多地方提到的却是不变性条件，其实不变性和不可变对象是两回事。所谓的不可变性条件，是指<code>在程序执行过程或部分过程中，可始终被假定成立的条件</code>。而不可变对象则是一种实例对象。</p>
<h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><p>要使一个对象成为不可变对象，需要满足以下三个条件：</p>
<ul>
<li>对象创建后其状态就不能修改</li>
<li>对象的所有与都是final类型的</li>
<li>对象被正确地创建了（在对象的创建期间，this引用没有逸出）。</li>
</ul>
<h1 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h1><p>如果对象从技术上来看是可变的，但其状态在对象被创建后就不会再变化，那么把这种对象成为<code>“事实不可变对象”</code>。事实不可变对象不需要满足不可变对喜爱那个的前两个条件。</p>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>一段代码或者一句代码包含多个操作，这些操作要么全部执行，要么全都不执行，称为原子性。</p>
<h1 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h1><p>在并发编程中，由于操作不具备原子性，因此由于不恰当的执行时序而出现不正确的结果。最常见的竞态条件：</p>
<ol>
<li><p>先检测后执行<br><img src="/blog/2018/04/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6.png" alt="竞态条件"><br>对于main线程，如果文件a不存在，则创建文件a，但是在判断文件a不存在之后，Task线程创建了文件a，这时候先前的判断结果已经失效，（main线程的执行依赖了一个错误的判断结果）此时文件a已经存在了，但是main线程还是会继续创建文件a，导致Task线程创建的文件a被覆盖、文件中的内容丢失等等问题。</p>
</li>
<li><p>延迟初始化（典型即为单例）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjFactory</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Obj instance;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> Obj <span class="title function_">getInstance</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Obj</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><img src="/blog/2018/04/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png" alt="单例模式"><br>线程a和线程b同时执行getInstance()，线程a看到instance为空，创建了一个新的Obj对象，此时线程b也需要判断instance是否为空，此时的instance是否为空取决于不可预测的时序：包括线程a创建Obj对象需要多长时间以及线程的调度方式，如果b检测时，instance为空，那么b也会创建一个instance对象。因此，使用单例模式必须在判断instance &#x3D;&#x3D; null之前加锁。顺带一提，之所以在加锁前需要再判断一次instance &#x3D;&#x3D; null，是为了防止在instance已经创建的情况下，线程无谓地获取锁导致的开销。该单例的创建方式称为<code>双重检查锁定</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjFactory</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Obj instance;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> Obj <span class="title function_">getInstance</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            synchronous(ObjFactory.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Obj</span>();</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>所谓的可见性，我们可以简单的理解为线程能够看到某一个变量的最新值。如果一个变量是不可见的，则线程可能会获取到一个失效值，导致程序出项意想不到的错误。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoVisibility</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!ready) &#123;</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printLn(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">main</span>(String[] args) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start;</span><br><span class="line">    number = <span class="number">42</span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NoVosobility可能会持续循环下去，因为读线程可能永远都看不到ready的值。一种更奇怪的现象是，NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入的number的值，产生该问题的原因的Java编译器、处理器以及运行时可能的对操作的执行顺序<code>重排序</code>导致的。<br>为了使其他线程看到ready的最新值，需要将ready变量用volatile关键字进行修饰。关于volatile关键字的底层原理机制，将在后面一篇文章做专门的介绍。</p>
<h1 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h1><p><code>“发布”</code>一个对象的意思是指，是对象能够在当前作用域之外的代码中使用。反之，当某个不应该发布的对象被发布时，就称为<code>“逸出”</code>。<br>发布一个对象的安全方式：</p>
<ol>
<li>在静态初始化函数中初始化一个对象的引用</li>
<li>将对象的引用保存到volatile类型的域中或AtomicReference对象中。</li>
<li>将对象的引用保存到某个正确构造的对喜爱那个的final类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ol>
<p>而对象的发布方式，则取决于它的可见性：</p>
<ol>
<li>不可变对象可通过任意方式来发布。</li>
<li>事实不可变对象必须通过安全方式来发布。</li>
<li>可变对象必须通过安全方式来发布，并且必须是线程安全的或者有某个锁来保护。</li>
</ol>
<p>两种逃逸的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">(EventSource source)</span> &#123;</span><br><span class="line">        source.registerListener(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span> &#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例子当中，在ThisEscape的构造函数还没有退出时，this引用隐式地逸出到了匿名内部类中。</p>
<p>第二种逸出方式是，在构造函数中调用了一个可改写的实例方法（既不是私有方法，也不是终结方法）。更具体地说，就是在创建子类的过程当中，首先会调用父类的构造方法进行父类数据的构造，如果在父类的构造方法中调用了被子类重载的方法，相当于还没有构造完全的父类引用，逃逸到了子类的重构方法代码中了。</p>
<p>关于并发编程中的一些术语就先介绍到这里，上述的几个术语基本上就是并发编程中的重点概念，在下一节当中，将讨论如何实现线程安全类。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><a class="page-number" href="/blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blog/page/4/">4</a><a class="page-number" href="/blog/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">yunhai.chen</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"jtQLIeV6jE3JEz552dDc8drD-gzGzoHsz","appKey":"ntTvuVT0T22Vn198alyrXuKA","serverURLs":null,"placeholder":"留下你的问题","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":false,"enableQQ":false,"requiredFields":[]}, {
      el: '#valine-comments',
      path: "/blog/page/3/",
      serverURLs: "https://jtqliev6.api.lncldglobal.com"
    }));
  }, window.Valine);
});
</script>

</body>
</html>
