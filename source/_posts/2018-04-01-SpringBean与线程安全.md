---
title: SpringBean与线程安全
comments: true
date: 2018-04-01 15:41:10
tags: Spring SpringBoot
categories: SpringBoot
---

&ensp;&ensp;&ensp;&ensp;前两天在使用spring Bean的时候，发现跑出来的数据总是存在着一些奇怪的值，这些值在当前的处理当中本该不会出现，找了半天，发现时上一个线程使用该Bean后的遗留的值。后面查看了spring Bean的相关知识后，找到了问题的原因。 使用了<font color="red">ThreadLocal——线程本地变量</font>的方式解决了问题。对问题产生的原因做一个分析和总结。

# 问题原因
&ensp;&ensp;&ensp;&ensp;<font color="red">Spring框架里的Bean，默认为单例模式，这是在多线程开发的时候要尤其注意的地方。</font>
&ensp;&ensp;&ensp;&ensp;当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求多对应的业务逻辑（成员方法），此时就要注意了，如果该处理逻辑中有对该单例Bean状态的修改（体现为该单例Bean的成员属性），则必须考虑线程同步问题。

# 使用ThreadLocal解决线程安全问题
&ensp;&ensp;&ensp;&ensp;ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。
&ensp;&ensp;&ensp;&ensp;由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用，概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。
&ensp;&ensp;&ensp;&ensp;我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如TransactionSynchronizationManager、LocaleContextHolder、RequestContextHolder、Hibernate的AnnotationSessionFactoryBean等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。
&ensp;&ensp;&ensp;&ensp;一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程
&ensp;&ensp;&ensp;&ensp;ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。
&ensp;&ensp;&ensp;&ensp;如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。 　线程安全问题都是由全局变量及静态变量引起的。
&ensp;&ensp;&ensp;&ensp;若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。

# 线程安全的情况
1. 常量始终是线程安全的，因为只存在读操作。
2. 每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源。
3. 局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。

# 有状态与无状态
&ensp;&ensp;&ensp;&ensp;有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象 ，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。
&ensp;&ensp;&ensp;&ensp;无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。
&ensp;&ensp;&ensp;&ensp;无状态的Bean适合用不变模式，技术就是单例模式，这样可以共享实例，提高性能。
&ensp;&ensp;&ensp;&ensp;有状态的Bean，多线程环境下不安全，那么适合用Prototype原型模式。Prototype: 每次对bean的请求都会创建一个新的Bean实例。


欢迎关注个人公众号：
![个人公号](/images/个人公号.jpg)
