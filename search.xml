<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇博客</title>
    <url>/blog/2018/03/30/Hello/</url>
    <content><![CDATA[<h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><p>之前学生时期的博客日志一直都是在CSDN上面记录的，随着对博客系统的了解，一直想搭建一个自己的博客系统并且部署到自己的服务器上面。现在有自己专用的云服务器，那么，就来搭建一个自己的博客系统吧。</p>
<p>本博客是建立在开源项目Hexo上的，在其基础上进行的开发,后期将对博客系统默认的一些主题及界面进行完善。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
  </entry>
  <entry>
    <title>HEXO基本配置</title>
    <url>/blog/2018/03/30/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="HEXO的使用与运行"><a href="#HEXO的使用与运行" class="headerlink" title="HEXO的使用与运行"></a>HEXO的使用与运行</h1><p>想要安装hexo非常简单，读者可以参考hexo官方文档的介绍，这里附上官方文档的地址：<a href="https://hexo.io/docs/index.html">hexo安装教程</a></p>
<h1 id="与GitHub-Pages的集成"><a href="#与GitHub-Pages的集成" class="headerlink" title="与GitHub Pages的集成"></a>与GitHub Pages的集成</h1><p>由于目前博客系统还不是很完整，但是很想能够在互联网上进行访问，因此，这里借助GITHUB，将HEXO与GITHUB进行集成，通过GITHUB平台的GitHub Pages来支持浏览器的访问。</p>
<p>首先，也是最重要的一步，就是安装一个扩展，通过命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>通过对HEXO_config.yml配置文件的修改，既可以实现我们的目的。打开配置文件，拉到最后一行，可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里，我们可以配置我们的deploy信息，博主的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:cyh123/yunhai.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>博主的github用户名为cyh123，所以repo那里的地址中带有博主的用户名信息。需要<code>部署自己博客的读者</code>，记得将名字那里修改为自己的github用户名。最后，将项目上传到自己的github仓库中。通过命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d -g #在部署前先生成</span><br></pre></td></tr></table></figure>
<p>进行部署手动输入网址，博主的地址是<code>http://cyh123.github.io/</code></p>
<p>在与GITHUB集成的过程当中，由于没有注意，创建仓库的过程到中没有按照GitHub Pages创建要求来命名仓库名称，导致一直失败，正确的仓库名称应该是&lt;username&gt;.github.io。其中。username为你自己GITHUB的用户名称，建议大家可以看一下GitHub Pages的用户文档，文档地址：<a href="https://help.github.com/categories/github-pages-basics/">GitHub Pages</a></p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDb学习</title>
    <url>/blog/2018/04/01/MongoDb%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol>
<li>文档<br> 文档是有序集合里面的一个<font color='red'><em><strong>键值对</strong></em></font>的有序集合。文档的键是字符串（除了少数情况，键可以用任何的UTF-8）。相当于关系型数据库当中的表table。</li>
<li>集合<br> 集合就是一组<font color='red'><em><strong>文档</strong></em></font>，相当于关系型数据库当中的一行数据。</li>
</ol>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ol>
<li>null</li>
<li>布尔型true or false</li>
<li>数值型<br>&ensp;&ensp;&ensp;&ensp;默认为64位的浮点型数值，如果要使用整形值，可以使用NumberInt类（表示4字节带符号整数）或NumberLong类（表示8字符带符号整数），如<br>&ensp;&ensp;&ensp;&ensp; <code>&#123;&quot;x&quot;:NumberInt(&quot;3&quot;)&#125;</code><br>&ensp;&ensp;&ensp;&ensp;<code>&#123;&quot;x&quot;:NumberLong(&quot;3&quot;)&#125;</code></li>
<li>字符串</li>
<li>日期<br> &ensp;&ensp;&ensp;&ensp;如{“x”:new Date()}</li>
<li>正则表达式，语法于JavaScript的正则表达式语法相同。</li>
<li>数组<br>&ensp;&ensp;&ensp;&ensp;  数组列表或数据集可以表示为数组：<br>&ensp;&ensp;&ensp;&ensp;<code>  &#123;&quot;x&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]&#125;</code></li>
<li>内嵌文档<br> &ensp;&ensp;&ensp;&ensp;文档可以嵌套其他文档，被嵌套的文档作为父文档的值。如：<br>&ensp;&ensp;&ensp;&ensp;<code> &#123;&quot;x&quot;:&#123;&quot;y&quot;:NumberInt(&quot;3&quot;)&#125;&#125;</code></li>
<li>对象id<br>  &ensp;&ensp;&ensp;&ensp;对象id是一个12字节的ID，是文档的唯一标识。<br>&ensp;&ensp;&ensp;&ensp;  <code>&#123;&quot;x&quot;,ObjectId()&#125;</code></li>
<li>二进制数据</li>
<li>代码<br>&ensp;&ensp;&ensp;&ensp;   查询和文档可以包含任意的JavaScript代码：<br>&ensp;&ensp;&ensp;&ensp;   <code>&#123;&quot;x&quot;:function()&#123;/* ... */&#125;&#125;</code></li>
</ol>
<h1 id="创建、更新和删除文档"><a href="#创建、更新和删除文档" class="headerlink" title="创建、更新和删除文档"></a>创建、更新和删除文档</h1><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li><p>插入文档<br>&ensp;&ensp;   插入一个文档<br><code>db.foo.insert(&#123;&quot;bar&quot;:&quot;baz&quot;&#125;)</code><br>&ensp;&ensp;批量插入<br><code>db.foo.batchInsert(&#123;&quot;_id&quot;:0&#125;,&#123;&quot;_id&quot;:1&#125;,&#123;&quot;_id&quot;:2&#125;)</code></p>
</li>
<li><p>删除文档<br>&ensp;&ensp;删除文档<br><code>db.foo.remove()</code><br><code>db.foo.remove(&#123;&quot;opt_out&quot;:true&#125;)</code><br>&ensp;&ensp;如果要删除全部的文档，使用drop直接删除集合会更快。</p>
</li>
<li><p>更新文档<br>&ensp;&ensp;&ensp;&ensp;文档存入数据库后，就可以使用update方法来更新文档。update有两个参数，一个是查询文档，用于定位需要更新的目标文档；另一个是修改器文档，用于说明要对找到的文档进行那些修改。<br>&ensp;&ensp;&ensp;&ensp;文档的修改可以分为两种类型，一种是文档的替换，就是将文档内容整个地替换掉。另外一种是文档的部分字段的更新。在进行文档的部分字段的更新时，必须使用修改器，否则文档会被全部替换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.user.update(&#123;&quot;name&quot;:&quot;joe&quot;&#125;,&#123;&quot;address&quot;:&quot;12345&quot;&#125;)</span><br><span class="line">db.user.update(&#123;&quot;name&quot;:&quot;joe&quot;&#125;,&#123;&quot;$set&quot;:&#123;&quot;address&quot;:&quot;12345&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;<font color='color'>第一个更新操作会将name为Joe的文档替换掉，第二个更新操作会将name为joe的文档的address内容替换为12345。因此，在修改文档的字段内容的时候，必须使用修改器。</font><br>&ensp;&ensp;&ensp;&ensp;update函数的第三个参数为一个布尔型的值，指示update函数是否为upset。当为true（即upset）时，要是没有找到符合更新条件的文档，就会以这个条件和更新文档为基础创建一个新的文档。如果找到了匹配的文档，则进行正常的更新。<br>&ensp;&ensp;&ensp;&ensp;update函数的第四个参数为一个布尔型的值，用于指示是否更新所有匹配的文档。update默认情况下只更新第一个匹配到的文档。因此，如果要更新所有匹配的文档，则需要将改参数设置为true。</p>
</li>
</ul>
<h2 id="常用的修改器"><a href="#常用的修改器" class="headerlink" title="常用的修改器"></a>常用的修改器</h2><ul>
<li><p>$set	用于设置文档中某一个键对应的值，如果对应的键不存在，则会新增加一个键值对。</p>
</li>
<li><p>$inc	用于增加已有键的值，如果对应的键不存在那就创建一个。$set只能用于整形，长整形或者双精度浮点型的值。</p>
</li>
<li><p>$push	用于操作数组。如果数组已经存在，$push会向已有的数组末尾加入一个元素，要是没有则会创建一个数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.stocker.update(&#123;&quot;_id&quot;:&quot;GOOD&quot;&#125;,&#123;&quot;$push&quot;:&#123;&quot;comment&quot;:&quot;123&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如果_id为GOOD的文档中不存在comment键，则新创建一个，如果存在的话，则将123添加到comment键的值当中，成为一个数组。<br>&ensp;&ensp;&ensp;&ensp;也可以和$each一起使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.stocker.update(&#123;&quot;_id&quot;:&quot;GOOD&quot;&#125;,&#123;&quot;$push&quot;:&#123;&quot;comment&quot;:&#123;&quot;$each&quot;:[&quot;123&quot;,&quot;456&quot;,&quot;789&quot;]&#125;&#125;&#125;)</span><br><span class="line">```  </span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;这样，三个字符串就都被添加到comment键对应的数组当中了。</span><br><span class="line"> </span><br><span class="line">- $ne	$andToSet	当我们将数组座位数据集使用的时候，需要保证数组内的元素不会重复，可以使用$ne	$andToSet。</span><br><span class="line"></span><br><span class="line">- $pull	用于删除数组当中的元素。</span><br><span class="line"></span><br><span class="line">#四. 查询</span><br><span class="line">## find函数</span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;MongoDB数据查询使用find函数，其功能与SQL中的select函数相同，可提供与关系型数据库类似的许多功能，包含映射、排序等。</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;find函数语法</span><br><span class="line">&gt;db.COLLECTION_NAME.find(query,fields,limit,skip)</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;find() 方法以非结构化的方式来显示所有文档。</span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：</span><br><span class="line">&gt;db.COLLECTION_NAME.find().pretty()</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;pretty() 方法以格式化的方式来显示所有文档。</span><br><span class="line">&lt;font color=&#x27;red&#x27;&gt;**参数说明**&lt;/font&gt;：</span><br><span class="line"></span><br><span class="line">- query：指明查询条件，相当于SQL中的where语句。</span><br><span class="line">`db.account.find(&#123;name:&quot;lewesyang&quot;,age:&#123;$it:22&#125;&#125;)`</span><br><span class="line">- fields：用于字段映射，指定是否返回该字段，0代表不返回，1代表返回</span><br><span class="line">`db.account.find(&#123;name:&quot;lewesyang&quot;,age:&#123;$it:22&#125;&#125;,&#123;&quot;age&quot;:0&#125;)`</span><br><span class="line">- limit：限制查询结果集的文档数量，指定查询返回结果数量的上限</span><br><span class="line">`db.account.find(&#123;name:&quot;lewesyang&quot;,age:&#123;$it:22&#125;&#125;,&#123;&quot;age&quot;:0&#125;,5) `</span><br><span class="line">- skip：跳过一定数据量的结果，设置第一条返回文档的偏移量</span><br><span class="line">`db.account.find(&#123;name:&quot;lewesyang&quot;,age:&#123;$it:22&#125;&#125;,&#123;&quot;age&quot;:0&#125;,5,10) `</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;单独使用limit和skip语法:&lt;br&gt;</span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;`db.account.find().limit(5).skip(10)`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;font color=&#x27;red&#x27;&gt;**注意事项**&lt;/font&gt;:</span><br><span class="line"></span><br><span class="line">-  MongoDB不支持多集合间的连接查询，find函数一次查询只能针对一个集合。</span><br><span class="line">- find参数为空或者查询条件为空文档时，会返回集合中的所有文档。</span><br><span class="line">- 除了将limit和skip作为find函数的参数外，还可以单独使用limit和skip函数来修饰查询结果。</span><br><span class="line">- 返回的查询结果集默认情况下是无序的，如果需要对结果进行排序，可以使用sort函数：</span><br><span class="line">`db.account.find().sort(&#123;age:-1&#125;)`</span><br><span class="line">- db.collection.findOne()只会返回第一条数据。</span><br><span class="line">- 当查询的集合文档数量很大时，为了加快数据的查询速度可以创建索引。</span><br><span class="line">- 除了使用find函数实现基本查询外，MongoDB还提供了聚合框架，用于复杂查询。</span><br><span class="line"></span><br><span class="line">##2. 查询条件</span><br><span class="line"></span><br><span class="line">-  比较操作符</span><br><span class="line">$gte,$gt,$lte,$lt,$ne，特别对应&gt;=、&gt;、&lt;=、&lt;。可以将其组合起来以方便查找一个范围的值。</span><br><span class="line">`db.user.find(&quot;age&quot;:&#123;&quot;$gte&quot;:18,&quot;$lte&quot;:25,&quot;$ne&quot;:22&#125;)`</span><br><span class="line">- OR查询</span><br><span class="line">MongoDB当中有两种方式进行OR查询，$in可以用来查询一个键的多个值，$or更通用一些，可以在多个键当中查询任意的给定值，$nin的作用域$in相反。</span><br><span class="line">`db.raffle.find(&#123;&quot;age&quot;:&#123;&quot;$in&quot;:[1,2,3]&#125;&#125;)`</span><br><span class="line">`db.raffle.find(&#123;&quot;$or&quot;:[&#123;&quot;age&quot;:12&#125;,&#123;&quot;sex&quot;:&quot;man&quot;&#125;]&#125;)`</span><br><span class="line">- $not</span><br><span class="line">$not时原条件句，即可以用在任何其他条件上。</span><br><span class="line">`db.raffle.find(&#123;&quot;age&quot;:&#123;&quot;not&quot;:&#123;&quot;$in&quot;:[1,2,3]&#125;&#125;&#125;)`</span><br><span class="line">作用和</span><br><span class="line">`db.raffle.find(&#123;&quot;age&quot;:&#123;&quot;$nin&quot;:[1,2,3]&#125;&#125;)`</span><br><span class="line">相同</span><br><span class="line">-  条件语义</span><br><span class="line">我们会发现以$开头的键位于不同的位置。在查询当中，&quot;$lte&quot;在内层文档，在更新当中，&quot;$inc&quot;位于外层文档。基本可以肯定：条件语句是内层文档的键，而修改器则是外层文档的键。有一些“元操作符”也位于外层文档中，比如“$and”，“$or”，“$nor”等。一个键可以有任意多个条件语句，但是一个健不能对应多个更新修改器。</span><br><span class="line"></span><br><span class="line">##3.  特定类型的查询</span><br><span class="line">###3.1 null</span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;null类型有些奇怪，它不仅能够匹配自身，也能够匹配不包含自己的键的值。例如:</span><br></pre></td></tr></table></figure>
<p>{“_id”:ObjectId(“123”),”y”:null}<br>{“_id”:ObjectId(“123”),”y”:1}<br>{“_id”:ObjectId(“123”),”y”:2}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">当我们使用查询语句：</span><br><span class="line">`db.c.find(&#123;&quot;y&quot;:null&#125;)`</span><br><span class="line">时，不仅能够查询到第一条数据，也能够查询到第二条数据。因此，为了解决该问题，应该使用查询语句：</span><br><span class="line">`db.c.find(&#123;&quot;y&quot;:&#123;&quot;$in&quot;:[null],&quot;$exists&quot;:true&#125;&#125;)`</span><br><span class="line">来进行查询。</span><br><span class="line">###3.2  正则表达式</span><br><span class="line">可以使用</span><br><span class="line">`db.user.find(&#123;&quot;name&quot;:/joe/i&#125;)`</span><br><span class="line">来匹配name键值包含joe字串的文档。在使用正则表达式时，需要注意的是，正则表达式不区分大小写。MongDB使用Perl兼容的正则表达式（PCRE）库来匹配正则表达式，任何PCRE支持的正则表达式语法都能被Perl接受。</span><br><span class="line"></span><br><span class="line">###3.3  查询数组</span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;查询数组很容易，对于数组，我们可以这样理解：数组中每一个元素都是这个键值对键的一个有效值，如下面的例子：我们要查询出售apple的水果店:</span><br></pre></td></tr></table></figure>
<p>db.fruitshop.find();<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “name” : “big fruit”, “fruits” : [ “apple”, “pear”, “orange” ] }<br>{ “_id” : ObjectId(“502251a309248743250688e1”), “name” : “good fruit”, “fruits” : [ “banana”, “pear”, “orange” ] }<br>{ “_id” : ObjectId(“502251c109248743250688e2”), “name” : “good fruit”, “fruits” : [ “banana”, “apple”, “tomato” ] }  </p>
<blockquote>
<p>db.fruitshop.find({“fruits”:”apple”});<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “name” : “big fruit”, “fruits” : [ “apple”, “pear”, “orange” ] }<br>{ “_id” : ObjectId(“502251c109248743250688e2”), “name” : “good fruit”, “fruits” : [ “banana”, “apple”, “tomato” ] }   </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;我们发现只要包含苹果的数组都能被查询出来。如果要通过多个元素来匹配数组，就需要条件操作符&quot;$all&quot;，比如我们要查询既卖apple又卖banana的水果店：</span><br></pre></td></tr></table></figure>
<p>db.fruitshop.find();<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “name” : “big fruit”, “fruits” : [ “apple”, “pear”, “orange” ] }<br>{ “_id” : ObjectId(“502251a309248743250688e1”), “name” : “good fruit”, “fruits” : [ “banana”, “pear”, “orange” ] }<br>{ “_id” : ObjectId(“502251c109248743250688e2”), “name” : “good fruit”, “fruits” : [ “banana”, “apple”, “tomato” ] }  </p>
<blockquote>
<p>db.fruitshop.find({“fruits”:{“$all”:[“apple”,”banana”]}});<br>{ “_id” : ObjectId(“502251c109248743250688e2”), “name” : “good fruit”, “fruits” : [ “banana”, “apple”, “tomato” ] }  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;我们看，使用“$all”对数组内元素的顺序没有要求，只要全部包含的数组都能查询出来。数组查询也可以使用精确匹配的方式，即查询条件文档中键值对的值也是数组，如：</span><br></pre></td></tr></table></figure>
<p>{ “_id” : ObjectId(“5022518d09248743250688e0”), “name” : “big fruit”, “fruits” : [ “apple”, “pear”, “orange” ] }<br>{ “_id” : ObjectId(“5022535109248743250688e4”), “name” : “fruit king”, “fruits” : [ “apple”, “orange”, “pear” ] }<br>{ “_id” : ObjectId(“502253c109248743250688e5”), “name” : “good fruit”, “fruits” : [ “apple”, “orange”, “pear”, “banana” ] }  </p>
<blockquote>
<p>db.fruitshop.find({“fruits”:[“apple”,”orange”,”pear”]});<br>{ “_id” : ObjectId(“5022535109248743250688e4”), “name” : “fruit king”, “fruits” : [ “apple”, “orange”, “pear” ] }   </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;如果是精确匹配的方式，MongoDB的处理方式是完全相同的匹配，即顺序与数量都要一致，上述中第一条文档和查询条件的顺序不一致，第三条文档比查询条件文档多一个元素，都没有被匹配成功！</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;对于数组的匹配，还有一种形式是精确指定数组中某个位置的元素匹配，我们前面提到，数组中的索引可以作为键使用，如我们要匹配水果店售第二种水果是orange 的水果店：</span><br></pre></td></tr></table></figure>
<p>db.fruitshop.find();<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “name” : “big fruit”, “fruits” : [ “apple”, “pear”, “orange” ] }<br>{ “_id” : ObjectId(“5022535109248743250688e4”), “name” : “fruit king”, “fruits” : [ “apple”, “orange”, “pear” ] }<br>{ “_id” : ObjectId(“502253c109248743250688e5”), “name” : “good fruit”, “fruits” : [ “apple”, “orange”, “pear”, “banana” ] }  </p>
<blockquote>
<p>db.fruitshop.find({“fruits.1”:”orange”});<br>{ “_id” : ObjectId(“5022535109248743250688e4”), “name” : “fruit king”, “fruits” : [ “apple”, “orange”, “pear” ] }<br>{ “_id” : ObjectId(“502253c109248743250688e5”), “name” : “good fruit”, “fruits” : [ “apple”, “orange”, “pear”, “banana” ] }    </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;数组索引从0开始，我们匹配第二种水果就用furits.1作为键。</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;$size条件操作符，可以用来查询特定长度的数组的，如我们要查询卖3种水果的水果店：</span><br></pre></td></tr></table></figure>
<p>db.fruitshop.find();<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “name” : “big fruit”, “fruits” : [ “apple”, “pear”, “orange” ] }<br>{ “_id” : ObjectId(“5022535109248743250688e4”), “name” : “fruit king”, “fruits” : [ “apple”, “orange”, “pear” ] }<br>{ “_id” : ObjectId(“502253c109248743250688e5”), “name” : “good fruit”, “fruits” : [ “apple”, “orange”, “pear”, “banana” ] }  </p>
<blockquote>
<p>db.fruitshop.find({“fruits”:{“$size”:3}});<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “name” : “big fruit”, “fruits” : [ “apple”, “pear”, “orange” ] }<br>{ “_id” : ObjectId(“5022535109248743250688e4”), “name” : “fruit king”, “fruits” : [ “apple”, “orange”, “pear” ] }</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;但条件操作符&quot;$size&quot;不能和其他操作符连用如“$gt”等，这是这个操作符的一个缺陷。使用这个操作符我们只能精确查询某个长度的数组。如果实际中，在查询某个数组时，需要按其长度范围进行查询，这里推荐的做法是：在这个文档中额外增加一个“size”键，专门记录其中数组的大小，在对数组进行&quot;$push&quot;操作同时，将这个“size”键值加1。如下所示：</span><br></pre></td></tr></table></figure>
<p>db.fruitshop.find({“name”:”big fruit”});<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “fruits” : [ “apple”, “pear”, “orange”, “strawberry” ], “name” : “big fruit”, “size” : 4 }<br>db.fruitshop.update({“name”:”big fruit”},<br>… {“$push”:{“fruits”:”banana”}, “$inc”:{“size”:1}}, false, false);  </p>
<blockquote>
<p>db.fruitshop.find({“name”:”big fruit”});<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “fruits” : [ “apple”, “pear”, “orange”, “strawberry”, “banana” ], “name” : “big fruit”, “size” : 5 }  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;find函数的第二个参数用于查询返回哪些键，他还可以控制查询返回数组的一个子数组，如下例：我只想查询水果店售卖说过数组的前两个：</span><br></pre></td></tr></table></figure>
<p>db.fruitshop.find();<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “fruits” : [ “apple”, “pear”, “orange”, “strawberry”, “banana” ], “name” : “big fruit” }<br>{ “_id” : ObjectId(“5022535109248743250688e4”), “fruits” : [ “apple”, “orange”, “pear” ], “name” : “fruit king” }<br>{ “_id” : ObjectId(“502253c109248743250688e5”), “fruits” : [ “apple”, “orange”, “pear”, “banana” ], “name” : “good fruit” }  </p>
<blockquote>
<p>db.fruitshop.find({}, {“fruits”:{“$slice”:2}});<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “fruits” : [ “apple”, “pear” ], “name” : “big fruit” }<br>{ “_id” : ObjectId(“5022535109248743250688e4”), “fruits” : [ “apple”, “orange” ], “name” : “fruit king” }<br>{ “_id” : ObjectId(“502253c109248743250688e5”), “fruits” : [ “apple”, “orange” ], “name” : “good fruit” }  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;“$slice”也可以从后面截取，用复数即可，如-1表明截取最后一个；还可以截取中间部分，如[2,3]，即跳过前两个，截取3个，如果剩余不足3个，就全部返回！</span><br></pre></td></tr></table></figure>
<p>db.fruitshop.find();<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “fruits” : [ “apple”, “pear”, “orange”, “strawberry”, “banana” ], “name” : “big fruit” }<br>{ “_id” : ObjectId(“5022535109248743250688e4”), “fruits” : [ “apple”, “orange”, “pear” ], “name” : “fruit king” }<br>{ “_id” : ObjectId(“502253c109248743250688e5”), “fruits” : [ “apple”, “orange”, “pear”, “banana” ], “name” : “good fruit” }  </p>
<blockquote>
<p>db.fruitshop.find({}, {“fruits”:{“$slice”:-1}});<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “fruits” : [ “banana” ], “name” : “big fruit” }<br>{ “_id” : ObjectId(“5022535109248743250688e4”), “fruits” : [ “pear” ], “name” : “fruit king” }<br>{ “_id” : ObjectId(“502253c109248743250688e5”), “fruits” : [ “banana” ], “name” : “good fruit” }<br>db.fruitshop.find({}, {“fruits”:{“$slice”:[3,6]}});<br>{ “_id” : ObjectId(“5022518d09248743250688e0”), “fruits” : [ “strawberry”, “banana” ], “name” : “big fruit” }<br>{ “_id” : ObjectId(“5022535109248743250688e4”), “fruits” : [ ], “name” : “fruit king” }<br>{ “_id” : ObjectId(“502253c109248743250688e5”), “fruits” : [ “banana” ], “name” : “good fruit” }  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;如果第二个参数中有个键使用了条件操作符&quot;$slice&quot;，则默认查询会返回所有的键，如果此时你要忽略哪些键，可以手动指明！如：</span><br></pre></td></tr></table></figure>
<p>db.fruitshop.find({}, {“fruits”:{“$slice”:[3,6]}, “name”:0, “_id”:0});<br>{ “fruits” : [ “strawberry”, “banana” ] }<br>{ “fruits” : [ ] }<br>{ “fruits” : [ “banana” ] }  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###3.4  查询内嵌文档</span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;查询文档有两种方式，一种是完全匹查询，另一种是针对键值对查询！内嵌文档的完全匹配查询和数组的完全匹配查询一样，内嵌文档内键值对的数量，顺序都必须一致才会匹配，如下例：</span><br></pre></td></tr></table></figure>
<p>db.staff.find();<br>{ “_id” : ObjectId(“50225fc909248743250688e6”), “name” : { “first” : “joe”, “middle” : “bush”, “last” : “Schmoe” }, “age” : 45 }<br>{ “_id” : ObjectId(“50225fe209248743250688e7”), “name” : { “first” : “joe”, “middle” : “bush” }, “age” : 35 }<br>{ “_id” : ObjectId(“50225fff09248743250688e8”), “name” : { “middle” : “bush”, “first” : “joe” }, “age” : 25 }  </p>
<blockquote>
<p>db.staff.find({“name”:{“first”:”joe”,”middle”:”bush”}});<br>{ “_id” : ObjectId(“50225fe209248743250688e7”), “name” : { “first” : “joe”, “middle” : “bush” }, “age” : 35 }  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;针对内嵌文档特定键值对的查询是最常用的！通过点表示法来精确表示内嵌文档的键：</span><br></pre></td></tr></table></figure>
<p>db.staff.find();<br>{ “_id” : ObjectId(“50225fc909248743250688e6”), “name” : { “first” : “joe”, “middle” : “bush”, “last” : “Schmoe” }, “age” : 45 }<br>{ “_id” : ObjectId(“50225fe209248743250688e7”), “name” : { “first” : “joe”, “middle” : “bush” }, “age” : 35 }<br>{ “_id” : ObjectId(“50225fff09248743250688e8”), “name” : { “middle” : “bush”, “first” : “joe” }, “age” : 25 }  </p>
<blockquote>
<p>db.staff.find({“name.first”:”joe”, “name.middle”:”bush”});<br>{ “_id” : ObjectId(“50225fc909248743250688e6”), “name” : { “first” : “joe”, “middle” : “bush”, “last” : “Schmoe” }, “age” : 45 }<br>{ “_id” : ObjectId(“50225fe209248743250688e7”), “name” : { “first” : “joe”, “middle” : “bush” }, “age” : 35 }<br>{ “_id” : ObjectId(“50225fff09248743250688e8”), “name” : { “middle” : “bush”, “first” : “joe” }, “age” : 25 }  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;我们看，这样查询，所有有效文档均被查询到了！通过点表示法，可以表示深入到内嵌文档内部的键！利用“点表示法”来查询内嵌文档，这也约束了在插入文档时，任何键都不能包含“.” !!</span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;当内嵌文档变得复杂后，如键的值为内嵌文档的数组，这种内嵌文档的匹配需要一些技巧，如下例：</span><br></pre></td></tr></table></figure>
<blockquote>
<p>db.blogs.findOne();<br>{<br>        “_id” : ObjectId(“502262ab09248743250688ea”),<br>        “content” : “…..”,<br>        “comment” : [<br>                {<br>                        “author” : “joe”,<br>                        “score” : 3,<br>                        “comment” : “just so so!”<br>                },<br>                {<br>                        “author” : “jimmy”,<br>                        “score” : 5,<br>                        “comment” : “cool! good!”<br>                }<br>        ]<br>}<br>db.blogs.find({“comment.author”:”joe”, “comment.score”:{“$gte”:5}});<br>{ “_id” : ObjectId(“502262ab09248743250688ea”), “content” : “…..”, “comment” : [      {       “author” : “joe”,       “score” : 3,    “comment” : “j<br>ust so so!” },  {       “author” : “jimmy”,     “score” : 5,    “comment” : “cool! good!” } ] }</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;我们想要查询评论中有叫“joe”并且其给出的分数超过5分的blog文档，但我们利用“点表示法”直接写是有问题的，因为这条文档有两条评论，一条的作者名字叫“joe”但分数只有3，一条作者名字叫“jimmy”，分数却给了5！也就是这条查询条件和数组中不同的文档进行了匹配！这不是我们想要的，我们这里是要使用一组条件而不是单个指明每个键，使用条件操作符“$elemMatch”即可！他能将一组条件限定到数组中单条文档的匹配上：</span><br></pre></td></tr></table></figure>
<blockquote>
<p>db.blogs.findOne();<br>{<br>        “_id” : ObjectId(“502262ab09248743250688ea”),<br>        “content” : “…..”,<br>        “comment” : [<br>                {<br>                        “author” : “joe”,<br>                        “score” : 3,<br>                        “comment” : “just so so!”<br>                },<br>                {<br>                        “author” : “jimmy”,<br>                        “score” : 5,<br>                        “comment” : “cool! good!”<br>                }<br>        ]<br>}<br>db.blogs.find({“comment”:{“$elemMatch”:{“author”:”joe”, “score”:{“$gte”:5}}}});<br>db.blogs.find({“comment”:{“$elemMatch”:{“author”:”joe”, “score”:{“$gte”:3}}}});<br>{ “_id” : ObjectId(“502262ab09248743250688ea”), “content” : “…..”, “comment” : [      {       “author” : “joe”,       “score” : 3,    “comment” : “j<br>ust so so!” },  {       “author” : “jimmy”,     “score” : 5,    “comment” : “cool! good!” } ] }</p>
</blockquote>
<pre><code>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;这样做，结果是正确的！利用条件操作符“$elemMatch”可以组合一组条件，并且还能达到的“点表示法”的模糊查询的效果！


欢迎关注个人公众号：
![个人公号](/images/个人公号.jpg)
</code></pre>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBean与线程安全</title>
    <url>/blog/2018/04/01/SpringBean%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;前两天在使用spring Bean的时候，发现跑出来的数据总是存在着一些奇怪的值，这些值在当前的处理当中本该不会出现，找了半天，发现时上一个线程使用该Bean后的遗留的值。后面查看了spring Bean的相关知识后，找到了问题的原因。 使用了<font color="red">ThreadLocal——线程本地变量</font>的方式解决了问题。对问题产生的原因做一个分析和总结。</p>
<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>&ensp;&ensp;&ensp;&ensp;<font color="red">Spring框架里的Bean，默认为单例模式，这是在多线程开发的时候要尤其注意的地方。</font><br>&ensp;&ensp;&ensp;&ensp;当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求多对应的业务逻辑（成员方法），此时就要注意了，如果该处理逻辑中有对该单例Bean状态的修改（体现为该单例Bean的成员属性），则必须考虑线程同步问题。</p>
<h1 id="使用ThreadLocal解决线程安全问题"><a href="#使用ThreadLocal解决线程安全问题" class="headerlink" title="使用ThreadLocal解决线程安全问题"></a>使用ThreadLocal解决线程安全问题</h1><p>&ensp;&ensp;&ensp;&ensp;ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。<br>&ensp;&ensp;&ensp;&ensp;由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用，概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。<br>&ensp;&ensp;&ensp;&ensp;我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如TransactionSynchronizationManager、LocaleContextHolder、RequestContextHolder、Hibernate的AnnotationSessionFactoryBean等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。<br>&ensp;&ensp;&ensp;&ensp;一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程<br>&ensp;&ensp;&ensp;&ensp;ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。<br>&ensp;&ensp;&ensp;&ensp;如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。 　线程安全问题都是由全局变量及静态变量引起的。<br>&ensp;&ensp;&ensp;&ensp;若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。</p>
<h1 id="线程安全的情况"><a href="#线程安全的情况" class="headerlink" title="线程安全的情况"></a>线程安全的情况</h1><ol>
<li>常量始终是线程安全的，因为只存在读操作。</li>
<li>每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源。</li>
<li>局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。</li>
</ol>
<h1 id="有状态与无状态"><a href="#有状态与无状态" class="headerlink" title="有状态与无状态"></a>有状态与无状态</h1><p>&ensp;&ensp;&ensp;&ensp;有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象 ，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。<br>&ensp;&ensp;&ensp;&ensp;无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。<br>&ensp;&ensp;&ensp;&ensp;无状态的Bean适合用不变模式，技术就是单例模式，这样可以共享实例，提高性能。<br>&ensp;&ensp;&ensp;&ensp;有状态的Bean，多线程环境下不安全，那么适合用Prototype原型模式。Prototype: 每次对bean的请求都会创建一个新的Bean实例。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot启动流程</title>
    <url>/blog/2018/04/01/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Spring-Boot-启动流程详解"><a href="#Spring-Boot-启动流程详解" class="headerlink" title="Spring Boot 启动流程详解"></a>Spring Boot 启动流程详解</h1><p>&ensp;&ensp;&ensp;&ensp;使用SpringBoot已经有好几个月了，一直对框架当中Bean的实例化过程有很感兴趣，比如Spring是如何去加载.class文件，并解析其中我们通过注解@Configuration, @PropertySource，@ComponentScan，@Import，@Bean等产生我们自定义的Bean的。下面我们就来看看，框架当中是如何实现Bean的加载与创建的。</p>
<p>下面是SpringApplication函数的run函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">		<span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">		stopWatch.start();</span><br><span class="line">		<span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">FailureAnalyzers</span> <span class="variable">analyzers</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		configureHeadlessProperty();</span><br><span class="line">		<span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">		listeners.starting();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">			<span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners,</span><br><span class="line">					applicationArguments);</span><br><span class="line">			<span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">			context = createApplicationContext();</span><br><span class="line">			analyzers = <span class="keyword">new</span> <span class="title class_">FailureAnalyzers</span>(context);</span><br><span class="line">			prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">					printedBanner);</span><br><span class="line">			refreshContext(context);</span><br><span class="line">			afterRefresh(context, applicationArguments);</span><br><span class="line">			listeners.finished(context, <span class="literal">null</span>);</span><br><span class="line">			stopWatch.stop();</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass)</span><br><span class="line">						.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> context;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;注意，在完成了context的创建之后，会调用refreshContext函数，refreshContext函数中会调用refresh函数，在该函数中又会先调用祖先类AbstractApplicationContext类的refresh函数。该函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">			<span class="comment">// 初始化BeanFactory</span></span><br><span class="line">			<span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">			<span class="comment">// 准备工厂后处理器的使用</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">				<span class="comment">//在子类中注册BeanFactory后处理器</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">				<span class="comment">//调用工厂后处理器</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				<span class="comment">//注册Bean后处理器</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">				<span class="comment">// 初始化信息源</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">				<span class="comment">// 初始化应用上下文时间广播</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">				<span class="comment">// 初始化其他特殊的Bean，有具体的子类来实现</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">				<span class="comment">// 注册事件监听器</span></span><br><span class="line">				registerListeners();</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">				<span class="comment">// 初始化所有非懒加载的单例Bean</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">				<span class="comment">// 完成刷新并发布容器刷新事件</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">							<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">				<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;在函数调用过程当中，调用了函数invokeBeanFactoryPostProcessors，在该函数的调用流程当中，调用链为PostProcessorRegistrationDelegate -&gt;ConfigurationClassPostProcessor -&gt; ConfigurationClassParser,在类ConfigurationClassParser类的doProcessConfigurationClass函数中，将启动类（即@SpringBootApplication标注的类,主要是@SpringBootApplication注解中的@Configuration注解的作用）做为入口，读取我们所定义的Bean，将其转化为一个个的BeanDefinition。下面，我们来看一下该函数的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">		processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">		<span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">				sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">				org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">				processPropertySource(propertySource);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">						<span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">		Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">		<span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">					!<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">				<span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">				Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">						<span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">				<span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">				<span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">					<span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(</span><br><span class="line">							holder.getBeanDefinition(), <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process any @Import annotations</span></span><br><span class="line">		processImports(configClass, sourceClass, getImports(sourceClass), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line">		<span class="keyword">if</span> (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123;</span><br><span class="line">			<span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">			String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">			Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">resolvedResource</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">				configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process individual @Bean methods</span></span><br><span class="line">		Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">		<span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">			configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process default methods on interfaces</span></span><br><span class="line">		processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process superclass, if any</span></span><br><span class="line">		<span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">superclass</span> <span class="operator">=</span> sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">			<span class="keyword">if</span> (!superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp; !<span class="built_in">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">				<span class="built_in">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">				<span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">				<span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;在该代码块中我们可以看到，函数首先处理由注解@PropertySource，该注解用于将我们自定义的属性文件加载到上下文环境当中。然后对@ComponentScan注解定义的包结构进行扫描，将启动类所在包下的子包中Bean文件（不包括子文件夹中的Bean文件）定义转化为BeanDefinition，如果该Bean定义的文件中也使用了@Configuration对其进行了注解，那么将会进行递归。之后，解析由注解@Import和@ImportResource注解导入的Bean定义文件，最后是直接由@Bean注解的成员函数。之后所有需要实例化的Bean都已经完成了解析，都转化为BeanDefinition，将由refresh函数中的finishBeanFactoryInitialization根据这些信息对Bean进行实例化。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>java虚拟机内存分布与使用</title>
    <url>/blog/2018/04/01/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="虚拟机运行时数据区域分布及使用"><a href="#虚拟机运行时数据区域分布及使用" class="headerlink" title="虚拟机运行时数据区域分布及使用"></a>虚拟机运行时数据区域分布及使用</h1><p>博主之前有一年多的时间使用过C++进行编程，内存的管理是个很让人头大的问题，内存的释放需要自己去delete，不然会发生内存泄漏的问题。开发过程当中内存操作不当导致的bug占了很大的比例，更不用说说，在多线程情况下对内存的管理了。自从开始使用Java之后，深感Java虚拟机自动内存管理的便利性。最近重读《深入理解Java虚拟机》一书，对本书内容进行一些记录。首先我们就来看看Java虚拟机的内存分布以及使用。</p>
<h2 id="虚拟机的运行时数据区域"><a href="#虚拟机的运行时数据区域" class="headerlink" title="虚拟机的运行时数据区域"></a>虚拟机的运行时数据区域</h2><p><img src="/blog/2018/04/01/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%B8%8E%E4%BD%BF%E7%94%A8/20170915153302333.png" alt="虚拟机运行时数据区域"></p>
<h2 id="虚拟机各内存区域的使用"><a href="#虚拟机各内存区域的使用" class="headerlink" title="虚拟机各内存区域的使用"></a>虚拟机各内存区域的使用</h2><p>虚拟机分配的内存大致可以分为两个部分，一部分是线程私有的内存区域，一部分是进程内线程共有的内存区域。此外，还有一块直接内存，这部分内存不是虚拟机运行是数据区的一部分，也不是Java虚拟机规范中所定义的内存区域，但是这部分内存也会被使用到，比如<a href="https://en.wikipedia.org/wiki/New_I/O_(Java)">NIO</a>时会在该区域进行内存分配。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>相信学习过计算机组成原理与汇编知识的读者都知道，在指令的执行过程当中，存在一个计数器，用来指示当前执行到了哪一条指令，其实程序计数器可以看作是当前线程执行的字节码的行号指示器，保存着当前指令的地址。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，个线程之间程序计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程。<br>在Java虚拟机规范中，对该区域规定了两种异常。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机可以动态国展，如果扩展是无法申请到足够的内存，就会抛出OutOfMemoryEror异常。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈所发挥的作用是非常相似的，只不过虚拟机栈执行为虚拟机执行Java服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机（如Sun的HotSpot需积极）直接将本地方法栈和虚拟机栈合二为一。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。该部分内存可以成为“永生区”。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>在方法区中，存在一块内存区域——运行时常量池，用于存放编译期间生成的各种字面量和符号引用，这部分内容将在类加载进入方法去的运行时常量池中存放。</p>
<h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>Java对是所有线程共享的一筐内存区域，也是Java虚拟机所管理的内存中最大的一块，所有对象实例及数组都要在对上分配内存。Java堆是垃圾收集器管理的主要区域，根据Java虚拟机规范的规定，Java堆可以处于物理上不联系的内存空间，只要逻辑上是连续的即可。<br>从内存回收的角度看，Java对中可以细分为：</p>
<ul>
<li>新生代<ul>
<li>Eden空间</li>
<li>From Survivor空间</li>
<li>To Survivor空间</li>
</ul>
</li>
<li>老生代</li>
</ul>
<p>该部分内容将在下一篇博客《虚拟机垃圾收集算法及垃圾收集器》中介绍</p>
<p>从内存分配的角度看，线程共享的Java队中可能划分出多个线程私有的分配缓冲区（TLAB）。<br>如果在堆中没有内存完成实例的分配，并且堆无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟及运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在JDK1.4中加入的NIO类，引入了一种基于通道与缓冲区的I&#x2F;O方式，它何以通过Native函数库直接分配堆外内存，也就是直接内存部分。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>java虚拟机垃圾收集</title>
    <url>/blog/2018/04/08/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>Java虚拟机除了上一篇文章当中提到的内存管理外，另外一个重要的知识便是垃圾收集。在进行收集垃圾之前，我们首先要考虑一下三个问题：</p>
<ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ul>
<h1 id="哪些内存是垃圾"><a href="#哪些内存是垃圾" class="headerlink" title="哪些内存是垃圾"></a>哪些内存是垃圾</h1><p>一块内存是垃圾，也就是说在该内存上的对象已经不再使用了，需要去进行回收，那么，如何来判别对象是否已经不再用了，需要进行回收呢？这里有两个方法：</p>
<ul>
<li><p>引用计数算法<br>给对象添加一个引用计数器，当每有一个地方引用它时，引用器值加1，当引用失效时，计数器减1。当计数器为0的时候，也就表示对象不可能再被使用了。这个方法实现简单，判定效率也很高。但是存在一个问题，就是它很难解决对喜爱那个之间互相循环引用的问题。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceGc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGC</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ReferenceGc</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceGc</span>();</span><br><span class="line">    <span class="type">ReferenceGc</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceGc</span>();</span><br><span class="line">    objA.instance = objB;</span><br><span class="line">    objB.instance = objA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在函数testGC创建了两个对象，在函数退出之后，objA和objB已经不会再被使用了，但是由于它们之间存在着引用，故引用计数算法得出的结论是objA与objB还在被引用，也就不会将这两个对象作为垃圾。</p>
</li>
<li><p>可达性分析算法<br>算法的基本思想如下:选择一些GC Roots作为起点，根据引用关系遍历所有能够到达的对象，遍历的路经称作引用链，当一个对象与GC Roots没有引用链的时，则证明了该对象是不可用的，也就是需要回收的垃圾。<br>GC Roots的选择如下：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对对象</li>
<li>方法区中产量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
</li>
</ul>
<p>如对象到GC Roots之间存在引用链，则根据引用的类型不同，是否进行回收也存在着区别，四个引用强度一次逐渐减弱：<br>强引用<br>即Object obj &#x3D; new Object();即为强引用。</p>
<p>软引用<br>描述一些没有用但是非必需的对象，对于软引用，除非系统将要发生内存溢出异常，才会去进行回收。</p>
<p>弱引用<br>被弱引用引用的对象会被进行回收</p>
<p>虚引用<br>一个对象是否有虚引用，完全不会对其生存时间构成影响，也无法通过虚引用老获得一个对象实例。为对象设置虚引用的唯一目的就是能在对象被收集器回收时收到一个系统通知。</p>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>几种主要的垃圾收集算法：</p>
<ul>
<li>标记-清除算法<br>对垃圾进行标记，然后清除垃圾，但是由于垃圾不一定是连续的，会存在碎片</li>
<li>复制算法<br>将内存分为成两个部分，在一起一块上分配内存创建对象，进行垃圾收集时，将存活的对象复制到另外一块内存上。</li>
<li>标记-整理算法<br>对垃圾进行标记，然后清除垃圾，然后整理内存，去除碎片</li>
<li>分代收集算法<br>将内存分成新生代和老生代，对不同的代使用不同的收集算法</li>
</ul>
<p>当前商业虚拟机的垃圾收集都采用“分代收集”算法。</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中没有对垃圾和搜集其应该如何实现做规定，因此不同的厂商和不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别。这里讨论的收集器是基于JDK1.7 Update14之后的HotSpot虚拟机器。<br><img src="/blog/2018/04/08/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/GC.jpg" alt="GC 分类"><br>上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。</p>
<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul>
<li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</li>
</ul>
<h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><ul>
<li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。具体原理见上一篇文章。</li>
<li>老年代GC（Major GC &#x2F; Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
<h2 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是最基本、发展历史最悠久的新生代收集器，也是原理最简单的收集器。它是一个采用复制算法的单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止。<br><img src="/blog/2018/04/08/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/SerialNew.png" alt="SerialNew收集器"><br>该收集器目前是HotSpot虚拟机运行在Client模式下的默认的新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew收集器就是Serial收集器的多线程版本，它也是一个新生代收集器。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同。<br><img src="/blog/2018/04/08/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/ParNew.png" alt="ParNew收集器"><br>该虚拟机是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用-XX:ParallerGCThreads参数设置。</p>
<h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge收集器也是一个并行的多线程新生代收集器，它也使用复制算法。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>Parallel Scavenge收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个参数-XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为GC自适应的调节策略（GC Ergonomics）。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p>
<h2 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h2><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old 是 Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”（Mark-Compact）算法。收集器的主要意义也是在于给Client模式下的虚拟机使用。Serial Old收集器的工作过程如图所示：<br><img src="/blog/2018/04/08/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/SerialOld.png" alt="SerialOld收集器"></p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。Parallel Old收集器的工作过程如图所示：<br><img src="/blog/2018/04/08/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/ParallelOld.png" alt="Parallel Old收集器"></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者B&#x2F;S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字上（“Mark Sweep”）就可以看出它是基于“标记-清除”算法实现的。<br>CMS收集器工作的整个流程分为以下4个步骤:</p>
<ul>
<li>初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</li>
<li>并发标记（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长。</li>
<li>重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>CMS收集器的工作过程如图所示：<br><img src="/blog/2018/04/08/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器"></p>
<p>优点</p>
<p>CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，因此<code>CMS收集器也被称为并发低停顿收集器</code>（Concurrent Low Pause Collector）。</p>
<p>缺点</p>
<ul>
<li>对CPU资源非常敏感 其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）&#x2F;4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。</li>
<li>无法处理浮动垃圾（Floating Garbage） 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</li>
<li>标记-清除算法导致的空间碎片 CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。</li>
</ul>
<h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p>
<ul>
<li>并行与并发 G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li>
<li>分代收集 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。</li>
<li>空间整合 G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li>
<li>可预测的停顿 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ul>
<h3 id="G1收集器的内存模型"><a href="#G1收集器的内存模型" class="headerlink" title="G1收集器的内存模型"></a>G1收集器的内存模型</h3><p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。G1在使用时，Java堆的内存布局与其他收集器有很大区别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。</p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记（Initial Marking） 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。</li>
<li>并发标记（Concurrent Marking） 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。</li>
<li>最终标记（Final Marking） 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收（Live Data Counting and Evacuation） 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率，流程图如下：<br><img src="/blog/2018/04/08/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/G1.png" alt="G1收集器"></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据上述几种垃圾收集器的工作原理及工作区域，进行一个归总：</p>
<table>
<thead>
<tr>
<th align="center">收集器</th>
<th align="center">串行、并行or并发</th>
<th align="center">新生代&#x2F;老年代</th>
<th align="center">算法</th>
<th align="center">目标</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serial</td>
<td align="center">串行</td>
<td align="center">新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">单CPU环境下的Client模式</td>
</tr>
<tr>
<td align="center">Serial Old</td>
<td align="center">串行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">响应速度优先</td>
<td align="center">单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td align="center">ParNew</td>
<td align="center">并行</td>
<td align="center">新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td align="center">Parallel Scavenge</td>
<td align="center">并行</td>
<td align="center">新生代</td>
<td align="center">复制算法</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="center">Parallel Old</td>
<td align="center">并行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="center">CMS</td>
<td align="center">并发</td>
<td align="center">老年代</td>
<td align="center">标记-清除</td>
<td align="center">响应速度优先</td>
<td align="center">集中在互联网站或B&#x2F;S系统服务端上的Java应用</td>
</tr>
<tr>
<td align="center">G1</td>
<td align="center">并发</td>
<td align="center">both</td>
<td align="center">标记-整理+复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">面向服务端应用，将来替换CMS</td>
</tr>
</tbody></table>
<blockquote>
<p>参考资料 : <a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></p>
</blockquote>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>java虚拟机</category>
      </categories>
      <tags>
        <tag>java虚拟机 垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发编程中的一些基础概念</title>
    <url>/blog/2018/04/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>博主在学习并发编程的过程当中，使用的书籍是<a href="https://book.douban.com/subject/10484692/">《Java并发编程实战》</a>这本书，但阅读下来，只能说本书的内容是很适合学习的，但是不知道是因为原版英语图书本身的写作问题，还是译者的翻译问题，本书的第一部分——基础知识 阅读起来难以理解。书中使用了大量的并发编程领域的专业词汇，由于本书不是很好阅读，这是博主半年后第二次尝试阅读该书，终于理解了书中内容，尤其是第一部分。为了方便后续的学习，在这里先把第一部分的内容梳理一下，对几个重要的关键词汇做一些解释。</p>
<h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p>
<h1 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h1><p>书中在介绍不变性时讲的是不可变对象，但是在书中很多地方提到的却是不变性条件，其实不变性和不可变对象是两回事。所谓的不可变性条件，是指<code>在程序执行过程或部分过程中，可始终被假定成立的条件</code>。而不可变对象则是一种实例对象。</p>
<h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><p>要使一个对象成为不可变对象，需要满足以下三个条件：</p>
<ul>
<li>对象创建后其状态就不能修改</li>
<li>对象的所有与都是final类型的</li>
<li>对象被正确地创建了（在对象的创建期间，this引用没有逸出）。</li>
</ul>
<h1 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h1><p>如果对象从技术上来看是可变的，但其状态在对象被创建后就不会再变化，那么把这种对象成为<code>“事实不可变对象”</code>。事实不可变对象不需要满足不可变对喜爱那个的前两个条件。</p>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>一段代码或者一句代码包含多个操作，这些操作要么全部执行，要么全都不执行，称为原子性。</p>
<h1 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h1><p>在并发编程中，由于操作不具备原子性，因此由于不恰当的执行时序而出现不正确的结果。最常见的竞态条件：</p>
<ol>
<li><p>先检测后执行<br><img src="/blog/2018/04/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6.png" alt="竞态条件"><br>对于main线程，如果文件a不存在，则创建文件a，但是在判断文件a不存在之后，Task线程创建了文件a，这时候先前的判断结果已经失效，（main线程的执行依赖了一个错误的判断结果）此时文件a已经存在了，但是main线程还是会继续创建文件a，导致Task线程创建的文件a被覆盖、文件中的内容丢失等等问题。</p>
</li>
<li><p>延迟初始化（典型即为单例）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjFactory</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Obj instance;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> Obj <span class="title function_">getInstance</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Obj</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><img src="/blog/2018/04/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png" alt="单例模式"><br>线程a和线程b同时执行getInstance()，线程a看到instance为空，创建了一个新的Obj对象，此时线程b也需要判断instance是否为空，此时的instance是否为空取决于不可预测的时序：包括线程a创建Obj对象需要多长时间以及线程的调度方式，如果b检测时，instance为空，那么b也会创建一个instance对象。因此，使用单例模式必须在判断instance &#x3D;&#x3D; null之前加锁。顺带一提，之所以在加锁前需要再判断一次instance &#x3D;&#x3D; null，是为了防止在instance已经创建的情况下，线程无谓地获取锁导致的开销。该单例的创建方式称为<code>双重检查锁定</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjFactory</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Obj instance;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> Obj <span class="title function_">getInstance</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            synchronous(ObjFactory.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Obj</span>();</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>所谓的可见性，我们可以简单的理解为线程能够看到某一个变量的最新值。如果一个变量是不可见的，则线程可能会获取到一个失效值，导致程序出项意想不到的错误。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoVisibility</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!ready) &#123;</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printLn(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">main</span>(String[] args) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start;</span><br><span class="line">    number = <span class="number">42</span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NoVosobility可能会持续循环下去，因为读线程可能永远都看不到ready的值。一种更奇怪的现象是，NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入的number的值，产生该问题的原因的Java编译器、处理器以及运行时可能的对操作的执行顺序<code>重排序</code>导致的。<br>为了使其他线程看到ready的最新值，需要将ready变量用volatile关键字进行修饰。关于volatile关键字的底层原理机制，将在后面一篇文章做专门的介绍。</p>
<h1 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h1><p><code>“发布”</code>一个对象的意思是指，是对象能够在当前作用域之外的代码中使用。反之，当某个不应该发布的对象被发布时，就称为<code>“逸出”</code>。<br>发布一个对象的安全方式：</p>
<ol>
<li>在静态初始化函数中初始化一个对象的引用</li>
<li>将对象的引用保存到volatile类型的域中或AtomicReference对象中。</li>
<li>将对象的引用保存到某个正确构造的对喜爱那个的final类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ol>
<p>而对象的发布方式，则取决于它的可见性：</p>
<ol>
<li>不可变对象可通过任意方式来发布。</li>
<li>事实不可变对象必须通过安全方式来发布。</li>
<li>可变对象必须通过安全方式来发布，并且必须是线程安全的或者有某个锁来保护。</li>
</ol>
<p>两种逃逸的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">(EventSource source)</span> &#123;</span><br><span class="line">        source.registerListener(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span> &#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例子当中，在ThisEscape的构造函数还没有退出时，this引用隐式地逸出到了匿名内部类中。</p>
<p>第二种逸出方式是，在构造函数中调用了一个可改写的实例方法（既不是私有方法，也不是终结方法）。更具体地说，就是在创建子类的过程当中，首先会调用父类的构造方法进行父类数据的构造，如果在父类的构造方法中调用了被子类重载的方法，相当于还没有构造完全的父类引用，逃逸到了子类的重构方法代码中了。</p>
<p>关于并发编程中的一些术语就先介绍到这里，上述的几个术语基本上就是并发编程中的重点概念，在下一节当中，将讨论如何实现线程安全类。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>java并发编程</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合ArrayList中modCount详解及subList函数要点</title>
    <url>/blog/2018/04/16/Java%E9%9B%86%E5%90%88ArrayList%E4%B8%ADmodCount%E8%AF%A6%E8%A7%A3%E5%8F%8AsubList%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<p>因为一次在项目开发中使用ArrayList的过程中，发生了<strong>ConcurrentModificationException</strong>异常，于是查询了相关资料，对发生该异常的原因记录一下。</p>
<p>所谓的ConcurrentModificationException翻译过来就是并发修改异常，网上大部分该异常出现的原因，都是在使用迭代器的时候发生的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        // 创建并添加元素</span><br><span class="line">        array.add(&quot;hello&quot;);</span><br><span class="line">        array.add(&quot;world&quot;);</span><br><span class="line">        array.add(&quot;java&quot;);</span><br><span class="line">        Iterator it = array.iterator();</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            String s = (String) it.next();</span><br><span class="line">            if (&quot;world&quot;.equals(s)) &#123;</span><br><span class="line">                array.add(&quot;javaee&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该例子中，我们使用迭代器进行迭代的过程中对集合进行了操作（不限于此处的添加操作，也可能是删除等），导致迭代器失效抛出该异常。但是在项目当中，本人并没有使用到迭代器，而是存在下面一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;TableEntity&gt; tableEntities = tableData.getValue().subList(1, tableData.getValue().size());</span><br><span class="line">List&lt;TableEntity&gt; newEntitys = tableData.getValue().subList(0,1);</span><br><span class="line">List&lt;TableEntity&gt; entities = sortTableEntity(tableEntities);</span><br><span class="line">newEntitys.addAll(entities);</span><br><span class="line">tableData.getValue().clear();</span><br><span class="line">tableData.getValue().addAll(newEntitys);</span><br></pre></td></tr></table></figure>
<p>异常在最后一步的时候抛出。可见，ConcurrentModificationException异常不仅仅是在使用迭代器的时候会出现。分析ArrayList类的subList源码我们可以发现，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubList</span>(<span class="built_in">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处返回了一个SubList的对象，而在其构造函数内部，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SubList(AbstractList&lt;E&gt; parent,int offset, int fromIndex, int toIndex) &#123;</span><br><span class="line">	this.parent = parent;</span><br><span class="line">	this.parentOffset = fromIndex;</span><br><span class="line">	this.offset = offset + fromIndex;</span><br><span class="line">	this.size = toIndex - fromIndex;</span><br><span class="line">	this.modCount = ArrayList.this.modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<strong>this.modCount &#x3D; ArrayList.this.modCount</strong>这样一句代码。而在第一个迭代器的例子中，通过iterator()函数返回的迭代器在构造当中也使用到了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> &#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.size;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可见，该异常的抛出与modCount有关,modCount属性是从AbstractList抽象类继承而来的。查看javadoc文档中的解释:</p>
<blockquote>
<p>The number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.<br>This field is used by the iterator and list iterator implementation returned by the iterator and listIterator methods. If the value of this field changes unexpectedly, the iterator (or list iterator) will throw a ConcurrentModificationException in response to the next, remove, previous, set or add operations. This provides fail-fast behavior, rather than non-deterministic behavior in the face of concurrent modification during iteration.</p>
</blockquote>
<p>我们知道该参数用来记录集合被修改的次数，之所以要记录修改的次数，是因为ArrayList不是线程安全的，为了防止在使用迭代器和子序列的过程当中对原集合的修改导致迭代器及子序列的失效，故保存了修改次数的记录，在迭代器的操作及子序列的操作过程当中，会首先去检查modCount是否相等（函数checkForComodification()），如果不想等的话，则说明集合被修改了，那么为了防止后续不明确的错误发生，于是便抛出了该异常。为了防止该异常的出现，在使用迭代器进行集合的迭代是，若要对集合进行修改，需要通过迭代器提供的对集合进行操作的函数来进行。而对我代码中出现的问题，可以修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;TableEntity&gt; tableEntities = Lists.newArrayList(tableData.getValue().subList(1, tableData.getValue().size()));</span><br><span class="line">List&lt;TableEntity&gt; newEntitys = Lists.newArrayList(tableData.getValue().subList(0,1));</span><br><span class="line">List&lt;TableEntity&gt; entities = sortTableEntity(tableEntities);</span><br><span class="line">newEntitys.addAll(entities);</span><br><span class="line">tableData.getValue().clear();</span><br><span class="line">tableData.getValue().addAll(newEntitys);</span><br></pre></td></tr></table></figure>
<p>这样的话，newEntitys就是一个ArrayList的对象而不是SubList的对象了。该情况也是第一次遇到，网上其他解释基本上都是第一种情况（即使用迭代器）发生。其实无论是第一种情况还是第二种情况，本质都是因为原集合的modCount被修改，导致与SubList的modCount或者是迭代器的expectedModCount不同导致的。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合 ConcurrentModificationException</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发编程实现线程安全性</title>
    <url>/blog/2018/04/17/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<p>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三中方式可以修复这个问题：</p>
<ol>
<li><p>不在线程之间共享该状态变量</br><br>采用线程封闭技术，实现状态变量不在线程之间进行共享。线程封闭技术有三个实现原理：</br></p>
</li>
<li><p>Ad-hoc线程封闭</br><br>其实就是维护线程封闭性的职责完全由程序实现来承担，该方式的线程封闭是非常脆弱的</br></p>
</li>
<li><p>栈封闭</br><br>在栈封闭中。只能通过局部变量才能访问对象，局部变量的固有属性之一就是封闭在执行环境当中，它们位于执行线程的栈中，其他线程无法访问这个栈。</br>该方法其实也就是使用局部变量来实现线程的安全。</br></p>
</li>
<li><p>ThreadLocal类</br><br>维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口和方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是能返回当前执行线程在调用set时设置的最新值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;() &#123;</span><br><span class="line">    pulic Connection <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHoler.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将状态变量修改为不可变的变量</br><br><code>不可比对象一定是线程安全的</code>。所谓不可变对象，其实就是如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性是不可变对象的固有属性之一。因为不可变对象在创建之后只会有一种状态，不会发生变化，所以一定是线程安全的。要使一个对象成为不可变对象，需要满足以下三个条件：</p>
</li>
</ol>
<ul>
<li>对象创建后其状态就不能修改</li>
<li>对象的所有与都是final类型的</li>
<li>对象被正确地创建了（在对象的创建期间，this引用没有逸出）。</br><br>其中，如果对象从技术上来看是可变的，但其状态在对象被创建后就不会再变化，那么把这种对象成为<code>“事实不可变对象”</code>，这些对象不需要满足上述的三个条件，在这些对象发布之后，程序只需要将它们视作不可变的对象即可。</li>
</ul>
<ol start="3">
<li>在访问状态变量时使用同步</br><br>在大多数情况下，以上两种保证线程安全性的方式不足以满足我们的开发需求，这是，我们就需要在访问共享的状态变量时，使用同步机制，保证线程的安全性。</li>
</ol>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>java并发编程</category>
      </categories>
      <tags>
        <tag>java并发编程 线程安全性</tag>
      </tags>
  </entry>
  <entry>
    <title>Groovy学习</title>
    <url>/blog/2018/04/23/Groovy%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<div class="show-content">
          <p>学习自：<a href="http://www.infoq.com/cn/articles/android-in-depth-gradle" target="_blank">http://www.infoq.com/cn/articles/android-in-depth-gradle</a> （大部分可能有差不多，只有少部分改了纰漏和认为他写的不对的地方）</p>
<h2>安装(mac)</h2>
<pre><code>brew install groovy</code></pre>
<p>查看版本号</p>
<pre><code>groovy -verson</code></pre>
<p>环境</p>
<pre><code>Android studio 2.0</code></pre>
<h2>基础</h2>
<ul>
<li>Groovy注释标记和Java一样，支持//或者//</li>
<li>Groovy语句可以不用分号结尾。Groovy为了尽量减少代码的输入，确实煞费苦心</li>
<li>Groovy中支持动态类型，即定义变量的时候可以不指定其类型。Groovy中，变量定义可以使用关键字def。注意，虽然def不是必须的，但是为了代码清晰，建议还是使用def关键字</li>
</ul>
<pre><code>def var =1 
def str= "i am a person"
def int x = 1//也可以指定类型</code></pre>
<ul>
<li>函数定义时，参数的类型也可以不指定。比如</li>
</ul>
<pre><code>String function(arg1,args2)&#123;//无需指定参数类型
&#125;</code></pre>
<ul>
<li>除了变量定义可以不指定类型外，Groovy中函数的返回值也可以是无类型的。比如：<br>//无类型的函数定义，必须使用def关键字</li>
</ul>
<pre><code>def  nonReturnTypeFunc()&#123;
     last_line   //最后一行代码的执行结果就是本函数的返回值
&#125;
//如果指定了函数返回类型，则可不必加def关键字来定义函数
String  getString()&#123;
   return "I am a string"
&#125;</code></pre>
<p>其实，所谓的无返回类型的函数，我估计内部都是按返回Object类型来处理的。毕竟，Groovy是基于Java的，而且最终会转成Java Code运行在JVM上</p>
<ul>
<li>函数返回值：Groovy的函数里，可以不使用return xxx来设置xxx为函数返回值。如果不使用return语句的话，则函数里最后一句代码的执行结果被设置成返回值。比如</li>
</ul>
<pre><code>//下面这个函数的返回值是字符串"getSomething return value"
def getSomething()&#123;
   "getSomething return value" //如果这是最后一行代码，则返回类型为String
    1000 //如果这是最后一行代码，则返回类型为Integer
&#125;</code></pre>
<p>注意，如果函数定义时候指明了返回值类型的话，函数中则必须返回正确的数据类型，否则运行时报错。如果使用了动态类型的话，你就可以返回任何类型了。</p>
<ul>
<li>
<p>Groovy对字符串支持相当强大，充分吸收了一些脚本语言的优点：<br>1  单引号''中的内容严格对应Java中的String，不对$符号进行转义</p>
<pre><code>def singleQuote='I am $ dolloar'  //输出就是I am $ dolloar</code></pre>
<p>2  双引号""的内容则和脚本语言的处理有点像，如果字符中有$号的话，则它会<strong>$表达式</strong>先求值。</p>
<pre><code>def doubleQuoteWithoutDollar = "I am one dollar" //输出 I am one dollar
def x = 1
def doubleQuoteWithDollar = "I am $x dolloar" //输出I am 1 dolloar</code></pre>
<p>3 三个引号'''xxx'''中的字符串支持随意换行 比如</p>
<pre><code>def multieLines = ''' begin
   line  1 
   line  2
   end '''</code></pre>
</li>
<li>
<p>最后，除了每行代码不用加分号外，Groovy中函数调用的时候还可以不加括号。比如：</p>
<pre><code>println("test") ---&gt; println "test"</code></pre>
</li>
</ul>
<p><strong>注意，虽然写代码的时候，对于函数调用可以不带括号，但是Groovy经常把属性和函数调用混淆。比如</strong></p>
<pre><code>def getSomething()&#123;
   "hello"
&#125;</code></pre>
<p>getSomething()   //如果不加括号的话，Groovy会误认为getSomething是一个变量。<br>所以，调用函数要不要带括号，我个人意见是如果这个函数是Groovy API或者Gradle API中比较常用的，比如println，就可以不带括号。否则还是带括号。Groovy自己也没有太好的办法解决这个问题，只能<strong>兵来将挡水来土掩</strong>了。</p>
<h2>数据类型</h2>
<p>Groovy中的数据类型我们就介绍两种和Java不太一样的：</p>
<ul>
<li>一个是Java中的基本数据类型。</li>
<li>另外一个是Groovy中的容器类。</li>
<li>最后一个非常重要的是闭包。</li>
</ul>
<p><strong>基本数据类型</strong><br>作为动态语言，Groovy世界中的所有事物都是对象。所以，<strong>int，boolean这些Java中的基本数据类型，在Groovy代码中其实对应的是它们的包装数据类型。比如int对应为Integer，boolean对应为Boolean。</strong>比如下图中的代码执行结果：</p>
<div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-2cebe00aa7e0f455.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-2cebe00aa7e0f455.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image005.png</div>
</div>
<p><strong>容器类</strong><br> List类</p>
<pre><code>变量定义：List变量由[]定义，比如

<p>def aList &#x3D; [5,’string’,true] &#x2F;&#x2F;List由[]定义，其元素可以是任何对象</p>
<p>变量存取：可以直接通过索引存取，而且不用担心索引越界。如果索引超过当前链表长度，List会自动<br>往该索引添加元素</p>
<p>assert aList[1] &#x3D;&#x3D; ‘string’<br>assert aList[5] &#x3D;&#x3D; null &#x2F;&#x2F;第6个元素为空<br>aList[100] &#x3D; 100  &#x2F;&#x2F;设置第101个元素的值为10<br>assert aList[100] &#x3D;&#x3D; 100</p>
<p>那么，aList到现在为止有多少个元素呢？</p>
<p>println aList.size  &#x3D;&#x3D;&#x3D;&gt;结果是101</code></pre></p>
<p> Map类</p>
<pre><code>容器变量定义

<p>变量定义：Map变量由[:]定义，比如</p>
<p>def aMap &#x3D; [‘key1’:’value1’,’key2’:true] </p>
<p>Map由[:]定义，注意其中的冒号。冒号左边是key，右边是Value。key必须是字符串，value可以是任何对象。另外，key可以用’’或””包起来，也可以不用引号包起来。比如</p>
<p>def aNewMap &#x3D; [key1:”value”,key2:true] &#x2F;&#x2F;其中的key1和key2默认被<br>处理成字符串”key1”和”key2”</p>
<p>不过Key要是不使用引号包起来的话，也会带来一定混淆，比如</p>
<p>def key1&#x3D;”wowo”<br>def aConfusedMap&#x3D;[key1:”who am i?”]</p>
<p>aConfuseMap中的key1到底是”key1”还是变量key1的值“wowo”？显然，答案是字符串”key1”。如果要是”wowo”的话，则aConfusedMap的定义必须设置成：</p>
<p>def aConfusedMap&#x3D;[(key1):”who am i?”]</p>
<p>Map中元素的存取更加方便，它支持多种方法：</p>
<p>println aMap.keyName    &lt;&#x3D;&#x3D;这种表达方法好像key就是aMap的一个成员变量一样<br>println aMap[‘keyName’] &lt;&#x3D;&#x3D;这种表达方法更传统一点<br>aMap.anotherkey &#x3D; “i am map”  &lt;&#x3D;&#x3D;为map添加新元素</code></pre></p>
<p>Range类<br>Range是Groovy对List的一种拓展，变量定义和大体的使用方法如下：</p>
<pre><code>def aRange = 1..5  &lt;==Range类型的变量 由begin值+两个点+end值表示
                      左边这个aRange包含1,2,3,4,5这5个值

<p>如果不想包含最后一个元素，则</p>
<p>def aRangeWithoutEnd &#x3D; 1..&lt;5  &lt;&#x3D;&#x3D;包含1,2,3,4这4个元素<br>println aRange.from<br>println aRange.to</code></pre></p>
<p>API<br>Groovy的API文档位于 <a href="http://www.groovy-lang.org/api.html" target="_blank">http://www.groovy-lang.org/api.html</a></p>
<p><strong>闭包</strong><br>闭包，英文叫Closure，是Groovy中非常重要的一个数据类型或者说一种概念了。闭包的历史来源，种种好处我就不说了。我们直接看怎么使用它！</p>
<p>闭包，是一种数据类型，它代表了一段可执行的代码。其外形如下：</p>
<pre><code>def aClosure = &#123;//闭包是一段代码，所以需要用花括号括起来..  
    String param1, int param2 -&gt;  //这个箭头很关键。箭头前面是参数定义，箭头后面是代码  
    println"this is code" //这是代码，最后一句是返回值，  
   //也可以使用return，和Groovy中普通函数一样  
&#125;</code></pre>
<p>简而言之，Closure的定义格式是：</p>
<pre><code>def xxx = &#123;paramters -&gt; code&#125;  //或者  
def xxx = &#123;无参数，纯code&#125;  这种case不需要-&gt;符号</code></pre>
<p><strong>说实话，从C/C++语言的角度看，闭包和函数指针很像</strong>。闭包定义好后，要调用它的方法就是：<br>闭包对象.call(参数)  或者更像函数指针调用的方法：<br>闭包对象(参数)<br>比如</p>
<pre><code>aClosure.call("this is string",100)  或者  
aClosure("this is string", 100)</code></pre>
<p>上面就是一个闭包的定义和使用。在闭包中，还需要注意一点：<br><strong>如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。</strong><br>比如：</p>
<pre><code>def greeting = &#123; "Hello, $it!" &#125;
assert greeting('Patrick') == 'Hello, Patrick!'</code></pre>
<p>等同于</p>
<pre><code>def greeting = &#123; it -&gt; "Hello, $it!" &#125;
assert greeting('Patrick') == 'Hello, Patrick!'</code></pre>
<p>但是，如果在闭包定义时，采用下面这种写法，则表示闭包没有参数！</p>
<pre><code>def noParamClosure = &#123; -&gt; true &#125;</code></pre>
<p>这个时候，我们就不能给noParamClosure传参数了！</p>
<pre><code>noParamClosure ("test")  &lt;==报错喔！</code></pre>
<p><strong>Closure使用中的注意点</strong></p>
<ol>
<li>省略圆括号</li>
</ol>
<p>闭包在Groovy中大量使用，比如很多类都定义了一些函数，这些函数最后一个参数都是一个闭包。比如：</p>
<pre><code>public static &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt; self, Closure closure)</code></pre>
<p>上面这个函数表示针对List的每一个元素都会调用closure做一些处理。这里的closure，就有点回调函数的感觉。但是，在使用这个each函数的时候，我们传递一个怎样的Closure进去呢？比如：</p>
<pre><code>def iamList = [1,2,3,4,5]  //定义一个List
iamList.each&#123;  //调用它的each，这段代码的格式看不懂了吧？each是个函数，圆括号去哪了？
      println it
&#125;</code></pre>
<p>上面代码有两个知识点：<br><strong>each函数调用的圆括号不见了</strong>！原来，Groovy中，当函数的最后一个参数是闭包的话，可以省略圆括号。比如</p>
<pre><code>def  testClosure(int a1,String b1, Closure closure)&#123;
      //do something
      closure() //调用闭包
&#125;
那么调用的时候，就可以免括号！
testClosure (4, "test", &#123;
   println "i am in closure"
&#125; )  //红色的括号可以不写..</code></pre>
<p>注意，这个特点非常关键，因为以后在Gradle中经常会出现图7这样的代码：</p>
<div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-35123fc8b1966861.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-35123fc8b1966861.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image008.png</div>
</div>
<p>经常碰见图7这样的没有圆括号的代码。省略圆括号虽然使得代码简洁，看起来更像脚本语言，但是它这经常会让我confuse（不知道其他人是否有同感），以doLast为例，完整的代码应该按下面这种写法：</p>
<pre><code> doLast(&#123;
   println 'Hello world!'
&#125;)</code></pre>
<p>有了圆括号，你会知道 doLast只是把一个Closure对象传了进去。很明显，它不代表这段脚本解析到doLast的时候就会调用println 'Hello world!' 。</p>
<p>但是把圆括号去掉后，就感觉好像println 'Hello world!'立即就会被调用一样！</p>
<ol>
<li>如何确定Closure的参数</li>
</ol>
<p>另外一个比较让人头疼的地方是，Closure的参数该怎么搞？还是刚才的each函数：</p>
<pre><code>public static &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt; self, Closure closure)</code></pre>
<p>如何使用它呢？比如：</p>
<pre><code>def iamList = [1,2,3,4,5]  //定义一个List变量
iamList.each&#123;  //调用它的each函数，只要传入一个Closure就可以了。
  println it
&#125;</code></pre>
<p>看起来很轻松，其实：<br><strong>对于each所需要的Closure，它的参数是什么？有多少个参数？返回值是什么？</strong></p>
<p>我们能写成下面这样吗？</p>
<pre><code>iamList.each&#123;String name,int x -&gt;
  return x
&#125;  //运行的时候肯定报错！</code></pre>
<p>所以，Closure虽然很方便，但是它一定会和使用它的上下文有极强的关联。要不，作为类似回调这样的东西，我如何知道调用者传递什么参数给Closure呢？</p>
<p>此问题如何破解？只能通过查询API文档才能了解上下文语义。比如下图8：<br></p><div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-8f67a60278c33486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-8f67a60278c33486.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image009.png</div>
</div><div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-6910a1e19ae2a3af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-6910a1e19ae2a3af.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image010.png</div>
</div>
<p>图8中：<br>each函数说明中，将给指定的closure传递Set中的每一个item。所以，closure的参数只有一个。<br>findAll中，<strong>绝对抓瞎</strong>了。一个是没说明往Closure里传什么。另外没说明Closure的返回值是什么.....。</p>
<p><strong>对Map的findAll而言，Closure可以有两个参数。findAll会将Key和Value分别传进去。并且，Closure返回true，表示该元素是自己想要的。返回false表示该元素不是自己要找的</strong>。示意代码所示：</p>
<pre><code>def result = aMap.findAll &#123;
    key, value -&gt;
        println "key=$key,value=$value"
        if (key == "k1")
            return true
        return false
&#125;</code></pre>
<p>Closure的使用有点坑，很大程度上依赖于你对API的熟悉程度，所以最初阶段，SDK查询是少不了的。</p>
<h2>脚本类</h2>
<p><strong>import</strong><br>groovy也可以像java那样写package，然后写类</p>
<pre><code>package bean
class Person &#123;
    String name
    String gender
    Person(name, gender) &#123;
        this.name = name
        this.gender = gender
    &#125;
    def print() &#123;
        println name + " " + gender
    &#125;
&#125;</code></pre>
<pre><code>import bean.Person
def name = 'EvilsoulM'
def person=new Person(name,"male");
person.print()</code></pre>
<p>groovy和Java类很相似。当然，如果不声明public/private等访问权限的话，Groovy中类及其变量默认都是public的。</p>
<p><strong>脚本到底是什么</strong><br>Java中，我们最熟悉的是类。但是我们在Java的一个源码文件中，不能不写class（interface或者其他....），而Groovy可以像写脚本一样，把要做的事情都写在xxx.groovy中，而且可以通过groovy xxx.groovy直接执行这个脚本。这到底是怎么搞的？</p>
<p>Groovy把它转换成这样的Java类：<br>执行<strong> groovyc</strong> -d classes test.groovy<br><strong>groovyc</strong>是groovy<br>的编译命令，-d classes用于将编译得到的class文件拷贝到classes文件夹下<br>图13是test.groovy脚本转换得到的java class。用jd-gui反编译它的代码：<br></p><div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-c8b8b60c9e14e166.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-c8b8b60c9e14e166.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image015.png</div>
</div>
<ul>
<li>test.groovy被转换成了一个test类，它从script派生。</li>
<li>每一个脚本都会生成一个static main函数。这样，当我们groovy test.groovy的时候，其实就是用java去执行这个main函数</li>
<li>
<strong>脚本中的所有代码都会放到run函数中</strong>。比如，println 'Groovy world'，这句代码实际上是包含在run函数里的。</li>
<li>如果脚本中定义了函数，则函数会被定义在test类中。</li>
</ul>
<p><strong>groovyc</strong>是一个比较好的命令，读者要掌握它的用法。然后利用jd-gui来查看对应class的Java源码。</p>
<p><strong>3.脚本中的变量和作用域</strong><br>前面说了，xxx.groovy只要不是和Java那样的class，那么它就是一个脚本。而且脚本的代码其实都会被放到run函数中去执行。那么，在Groovy的脚本中，很重要的一点就是脚本中定义的<strong>变量和它的作用域</strong>。举例：</p>
<pre><code>def x = 1 &lt;==注意，这个x有def（或者指明类型，比如 int x = 1）  
def printx()&#123;  
   println x  
&#125;</code></pre>
<p>printx()  &lt;==报错，说x找不到</p>
<p>为什么？继续来看反编译后的class文件。</p>
<div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-80de7afa052a7329.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-80de7afa052a7329.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image016.png</div>
</div><p><br> 图中，x也没有被定义成test的成员函数，而是在run的执行过程中，将x作为一个属性添加到test实例对象中了。然后在printx中，先获取这个属性。</p>
<p>注意，Groovy的文档说 x = 1这种定义将使得x变成test的成员变量，但从反编译情况看，这是不对的.....(这是infoQ文章中说的，但是测试来说这句话是对的，应该是文章作者没有定义成class)</p>
<p>虽然printx可以访问x变量了，但是假如有其他脚本却无法访问x变量。因为它不是test的成员变量。</p>
<p>比如，我在测试目录下创建一个新的名为test1.groovy。这个test1将访问test.groovy中定义的printx函数：</p>
<pre><code>def atest=new test()
atest.printx()</code></pre>
<p>这种方法使得我们可以将代码分成模块来编写，<strong>比如将公共的功能放到test.groovy中，然后使用公共功能的代码放到test1.groovy中</strong>。<br>执行groovy test1.groovy，报错。说x找不到。这是因为x是在test的run函数动态加进去的。怎么办？</p>
<pre><code>import groovy.transform.Field;   //必须要先import
@Field x = 1  &lt;==在x前面加上@Field标注，这样，x就彻彻底底是test的成员变量了。</code></pre>
<p>查看编译后的test.class文件，得到：</p>
<div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-983bf79cb93f1085.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-983bf79cb93f1085.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image019.png</div>
</div><p><br>这个时候，test.groovy中的x就成了test类的成员函数了。如此，我们可以在script中定义那些需要输出给外部脚本或类使用的变量了！</p>
<p>eg:<br>ScriptBase.groovy类 (用了filed 就相当这就是一个class 就不用再自己定义class了)</p>
<pre><code>import groovy.transform.Field;
@Field author = 'EvilsouM'
@Field gender = 'male'
@Field age = 25
//必须要先import
def printInfo() &#123;
    println "name-&gt;$author  gender-&gt;$gender age-&gt;$age"
&#125;</code></pre>
<p>或者自己定义class</p>
<pre><code>class ScriptBase &#123;
    def author = 'EvilsouM'
    def gender = 'male'
    def age = 25//必须要先import
    def printInfo() &#123;
        println "name-&gt;$author  gender-&gt;$gender age-&gt;$age"
    &#125;
&#125;</code></pre>
<p>scripttest.groovy类</p>
<pre><code>def Closure printAuthorInfo = &#123;
            String name, String gender, int age -&gt;
                println "name-&gt;$name  gender-&gt;$gender age-&gt;$age"
&#125;
def ScriptBase base = new ScriptBase()
base.printInfo()
printAuthorInfo.call(base.author, base.gender, base.age) 上面两种方式都能拿到成员变量</code></pre>
<p><strong>文件I/O操作</strong><br>本节介绍下Groovy的文件I/O操作。直接来看例子吧，虽然比Java看起来简单，但要理解起来其实比较难。尤其是当你要自己查SDK并编写代码的时候。</p>
<p>整体说来，Groovy的I/O操作是在原有Java I/O操作上进行了更为简单方便的封装，并且使用Closure来简化代码编写。主要封装了如下一些了类：</p>
<div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/1070361-712c42d8fcdac92b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/1070361-712c42d8fcdac92b.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">image020.png</div>
</div>
<ul>
<li>读文件<br>Groovy中，文件读操作简单到令人发指：<br>def targetFile = new File(文件名)  &lt;==File对象还是要创建的。<br>然后打开<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" target="_blank">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html</a><br>看看Groovy定义的API：</li>
</ul>
<p>1 读该文件中的每一行：eachLine的唯一参数是一个Closure。Closure的参数是文件每一行的内容<br>   其内部实现肯定是Groovy打开这个文件，然后读取文件的一行，然后调用Closure...</p>
<pre><code>def File targetFile = new File("build.gradle")
targetFile.eachLine &#123;
    String line -&gt;
        println line
&#125;</code></pre>
<p>2 直接得到文件内容</p>
<pre><code>targetFile.getBytes()  &lt;==文件内容一次性读出，返回类型为byte[]</code></pre>
<p>3 使用InputStream.InputStream的SDK在 <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" target="_blank">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html</a></p>
<pre><code>def ism =  targetFile.newInputStream()  
//操作ism，最后记得关掉  
ism.close</code></pre>
<p>4 使用闭包操作inputStream，以后在Gradle里会常看到这种搞法</p>
<pre><code> targetFile.withInputStream&#123;
 ism -&gt; 操作ism. 不用close。Groovy会自动替你close
&#125;</code></pre>
<ol>
<li>写文件<br>和读文件差不多。不再啰嗦。这里给个例子，告诉大家如何copy文件。<pre><code class="groovy">def srcFile = new File(源文件名)
def targetFile = new File(目标文件名)
targetFile.withOutputStream&#123;
os-&gt; srcFile.withInputStream &#123;
ins-&gt;
   os &lt;&lt; ins //利用OutputStream的&lt;&lt;操作符重载，完成从inputstream到OutputStream  //的输出
  &#125;
&#125;</code></pre>
</li>
</ol>

<pre><code>    &lt;/div&gt;
    &lt;!--  --&gt;

    &lt;div class=&quot;show-foot&quot;&gt;
      &lt;a class=&quot;notebook&quot; href=&quot;/nb/2655670&quot;&gt;
        &lt;i class=&quot;iconfont ic-search-notebook&quot;&gt;&lt;/i&gt; &lt;span&gt;其他&lt;/span&gt;
</code></pre>
<p></a>          <div class="copyright" data-toggle="tooltip" data-html="true" data-original-title="转载请联系作者获得授权，并标注“简书作者”。"><br>          </div></p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>groovy</category>
      </categories>
      <tags>
        <tag>groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>同步容器与并发容器类简介</title>
    <url>/blog/2018/04/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h1><p>同步容器类包括Vector和HashTable，二者都是早期JDK的一部分，此外还包括在JDK1.2当中添加的一些功能相似的类，这些同步的封装类是由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次都只有一个线程能够访问容器的状态。相较于并行容器，同步容器的实现原理其实很简单，就是对普通容器做了一层封装，并实现容器的每一个方法，在方法上实现同步。比如通过Collections类的工厂方法将一个普通的List封装成一个同步容器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) :</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SynchronizedList</span>&lt;&gt;(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他包装函数<br><img src="/blog/2018/04/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%AE%80%E4%BB%8B/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E5%8C%85%E8%A3%85%E5%87%BD%E6%95%B0.PNG" alt="同步容器包装函数"></p>
<h2 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h2><p>在并发编程当中，虽然同步容器类是线程安全的，但是在某些情况下可能需要额外的客户端加锁来保护复合操作。如下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getLast</span><span class="params">(Vector list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteLast</span><span class="params">(Vector list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> list.size() - <span class="number">1</span>;</span><br><span class="line">    list.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述两个函数中，虽然Vector是线程安全的，但是获取Vector大小与获取&#x2F;删除之间没有锁保护，当获得Vector大笑之后，如另外一个线程删除了Vector中的最末尾位置的元素，则每个函数的最后一句代码执行将报错。因此，对于复合操作，需要在符合操作上用锁来保证操作的原子性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getLast</span><span class="params">(Vector list)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteLast</span><span class="params">(Vector list)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> list.size() - <span class="number">1</span>;</span><br><span class="line">        list.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前的文章<a href="./../../01/Java%E9%9B%86%E5%90%88ArrayList%E4%B8%ADmodCount%E8%AF%A6%E8%A7%A3%E5%8F%8AsubList%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9/#more">《Java集合ArrayList中modCount详解及subList函数要点》</a>中，曾经提到过<code>ConcurrentModificationException</code>异常,在对集合进行迭代操作的过程中，如果修改了原集合，将导致异常的发生。同样，如果在迭代期间modCount被其他线程修改，那么同样将发生<code>ConcurrentModificationException</code>异常。由于使用同步类容器需要保证在对容器进行复合操作及其他一些操作要进行客户端加锁，导致了实现线程安全的同步操作的保障将分散代码的各个地方，这将增加代码实现的难度以及维护的难度。正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略以及简化维护工作。因此，更能实现该目的的并行容器，也就成了更好的选择。</p>
<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>同步容器类存在两个问题，一个问题就是上面提到的复合操作需要客户端加锁，以保证操作的正确性。另外一个就是同步容器将所有对容器状态的访问都串行化，以实现他们的线程安全性，但这种方法的代价是严重降低并发性，当多个线程竞争访问容器的锁时，吞吐量将严重降低。因此，通过并发容器代替同步容器，可以极大地提高伸缩性并降低风险。并发容器注重以下特性：</p>
<ol>
<li>根据具体场景进行设计，尽量避免使用锁，提高容器的并发访问性。</li>
<li>并发容器定义了一些线程安全的复合操作。</li>
<li>并发容器在迭代时，可以不封闭在synchronized中。但是未必每次看到的都是”最新的、当前的”数据。如果说将迭代操作包装在synchronized中，可以达到”串行”的并发安全性，那么并发容器的迭代达到了”脏读”。</li>
</ol>
<p>可以通过下图简单了解concurrent中关于容器类的接口和类：<br><img src="/blog/2018/04/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%AE%80%E4%BB%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="并发容器继承关系"></p>
<h2 id="两个接口"><a href="#两个接口" class="headerlink" title="两个接口"></a>两个接口</h2><ul>
<li><p>ConcurrentMap<br>该接口定义Map的原子操作：putIfAbsent、remove、replace</p>
</li>
<li><p>BlockingQueue<br>阻塞队列，不允许null值；<br>取元素时，如果队列为空则等待；存元素时，如果没有空间则等待；</p>
</li>
</ul>
<p>阻塞队列的方法有四种形式–当操作不能立即得到满足，但可能在未来某一时刻被满足的时候，有四种不同的方式来处理：</p>
<ul>
<li>抛出异常</li>
<li>返回特殊的值（null或false，取决与具体的操作）</li>
<li>无期限地阻塞当前线程，直到该操作成功</li>
<li>仅在指定的最大时长内阻塞，过后还不成功就放弃</li>
</ul>
<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><p>通过上面的图可以知道，concurrent包中的并发容器主要可以四类，分别是：</p>
<ul>
<li>CopyOnWrite容器：CopyOnWriteArrayList、CopyOnWriteArraySet</li>
<li>CocurrentMap的实现类：ConcurrentHashMap、ConcurrentSkipListMap</li>
<li>阻塞队列的实现类（共七种）</li>
<li>其他：ConcurrentLinkedQueue、ConcurrentLikedDeque、ConcurrentSkipListSet</li>
</ul>
<h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h3><p>其实现原理是，在创建CopyOnWrite容器实例时，是通过安全方式发布了一个事实不可变对象，由前一篇文章中我们知道，安全发布的事实不可变对象是线程安全的，那么在访问该对象时就不再需要进一步的同步。但是在每次修改时，都会创建并重新发布一个新的容器副本就行修改，从而实现可变性。需要注意的时，每当修改容器是都会复制底层数组，这需要一定的开销，特别是当容器的规模较大时。所以，建议仅当迭代操作远远多余修改操作时，才应该使用“写入时复制”容器。</p>
<h4 id="CopyOnWriteArrayList（写入时复制List）"><a href="#CopyOnWriteArrayList（写入时复制List）" class="headerlink" title="CopyOnWriteArrayList（写入时复制List）"></a>CopyOnWriteArrayList（写入时复制List）</h4><p>CopyOnWriteArrayList用于替代同步List，其在迭代期间不需要对容器进行加锁或复制。</p>
<h4 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h4><p>java.util.ArrayList的线程安全版本：所有的修改操作都是通过对底层数组的最新copy来实现。</p>
<h3 id="ConcurrentMap的实现类"><a href="#ConcurrentMap的实现类" class="headerlink" title="ConcurrentMap的实现类"></a>ConcurrentMap的实现类</h3><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>与HashMap一样，ConcurrentHashMap也是一个基于散列的Map，但它使用一种完全不同的加锁策略来提供更高的并发性和伸缩性。ConcurrentHashMap并部署在每个方法上都用同一个锁进行同步并使得只能有一个线程访问容器，而是使用一种粒度更细的锁机制来实现更大程度的共享，这种机制成为分段锁。<code>在这种机制中，任意数量的读取线程可以并发地访问Map，执行读取操作的线程和执行写入操作的线程可以并发地访问Map，并且一定数量的写入线程可以并发地修改Map。</code>，所谓分段锁，简单来说就是将数据进行分段，每一段锁用于锁容器中的一部分数据，那么当多线程访问容器里的不容数据段的数据时，线程间就不会存在锁竞争，从而可以有效地提高并发访问效率。有些方法需要跨段，比如size()，就需要按照顺序锁定所有的段，完成操作后，再按顺序释放锁。有关分段锁的应用，可以参看<a href="https://www.cnblogs.com/ITtangtang/p/3948786.html">ConcurrentHashMap分段锁技术</a>。</p>
<h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><p>ConcurrentSkipListMap在JDK并发工具类使用范围不是很广，它是针对某一特殊需求而设计的——支持排序，同时支持搜索目标返回最接近匹配项的导航方法。ConcurrentSkipListMap使用SkipList(跳表)实现排序，而TreeMap使用红黑树。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列是一个支持阻塞插入和阻塞移除的队列：当队列满时，队列会阻塞插入元素的线程，直到队列不满；当队列为空时，队列会阻塞获取元素的线程，直到队列不空。阻塞队列常用于生产者和消费者模式，生产者向队列中添加元素，消费者则从队列中取出元素。线程池当中使用阻塞队列来实现任务的排队，在这里简单介绍一下阻塞队列的几个具体实现类。</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>使用数组实现的有界阻塞队列，按照FIFO的原则对元素排序；内部使用重入锁可实现公平访问。内部使用一个重入锁来控制并发修改操作，即同一时刻，只能进行放或取中的一个操作。初始化时，必须指定容量大小。</p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>使用链表实现的有界阻塞队列，按照FIFO的原则对元素排序；默认和最大长度均为Integer.MAX_VALUE，所以在使用的时候，要注意指定最大容量，否则可能会导致元素数量过多，内存溢出。内部使用两个重入锁来控制并发操作，即同一时刻，允许同时进行放和取。</p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>支持优先级的无界阻塞队列，默认情况下元素按照自然顺序升序排列，可以自定义类实现compareTo()方法来指定元素的排序规则，或在初始化PriorityBlockingQueue时指定构造参数Comparator来对元素进行排序，但不能保证同优先级元素的顺序；</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>支持延时获取元素的无界阻塞队列，队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有在延迟期满后，才能从队列中获取元素。<br>DelayQueue可以应用在缓存系统的设计（用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素，表示缓存有效期到了）、定时任务调度等场景（ScheduledThreadPoolExecutor中的ScheduledFutureTask类就是实现的Delayed接口）</p>
<h4 id="SyncronousQueue"><a href="#SyncronousQueue" class="headerlink" title="SyncronousQueue"></a>SyncronousQueue</h4><p>不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素，支持公平访问队列，非常适合传递性场景，即把生产者线程处理的数据直接传递给消费者线程，队列本身不存储任何元素。SyncronousQueue的吞吐量高于ArrayBlockingQueue和LinkedBlockingDeque。</p>
<h4 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h4><p>使用链表实现的无界阻塞TransferQueue，当有消费者正在等待接受元素时，队列可以通过transfer()方法把生产者传入的元素立即传给消费者。</p>
<h4 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h4><p>使用链表实现的双向阻塞队列，可以在队列的两端进行插入和移除元素。</p>
<h3 id="其他-等补充"><a href="#其他-等补充" class="headerlink" title="其他(等补充)"></a>其他(等补充)</h3><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因此，在使用容器进行开发时，我们有三种选择，第一种是使用普通的容器，二是使用同步容器，三是使用并发容器。在容器的选择上，还是需要我们根据具体的业务需要，选择合适的容器来实现业务功能。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>java并发编程</category>
      </categories>
      <tags>
        <tag>java并发编程 容器</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池介绍</title>
    <url>/blog/2018/04/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h1><p>线程池，从字面含义来看，是指管理一组同构工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。在上一节当中，我们介绍了同步容器及并发容器相关的知识，在最后，我们讲到了阻塞队列这类并发容器。线程池的实现中，工作队列就用到了阻塞队列。<br>类库提供了一个灵活的线程池以及一些有用的默认配置，可以通过调用Executors中的静态工行方法之一来创建一个线程池：<img src="/blog/2018/04/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA.PNG" alt="线程池创建"><br>从函数名字可以看出，Executors能够创建一下几种类型的线程池：</p>
<ul>
<li>newFixedThreadPool<br>创建一个固定长度的线程池，每当提交一个任务时就创建一个线程成，知道达到线程池的最大数量，这是线程池的规模将不再变化</li>
<li>newSingleThreadExecutor<br>创建一个单线程的线程池。</li>
<li>newCachedThreadPool<br>创建一个可缓存的线程池，如果线程池当前规模超出了处理器需求，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。</li>
<li>ScheduledExecutorService<br>创建一个固定长度的线程池，而且以延迟或者定时的方式来执行任务。</li>
</ul>
<p>在这几个静态构造函数中，其实实质上都调用了ThreadPoolExecutor类的构造函数来创建一个线程池。我们来看下，包java.util.concurrent下ThreadPoolExecutor类的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该构造函数当中，corePoolSize表示线程池中线程的数量，maximumPoolSize表示线程池中最大线程数据，keepAliveTime表示的是，当线程池中的线程数量大于corePoolSize时，闲置线程终结前等待任务分配的最大等待时间（如果超过这个时间线程还没有被分配任务，该线程将终结）。workQueue，handler，threadFactory是线程池的核心内容，我们将具体来讲解一下这三个属性的作用。</p>
<h1 id="工作队列（BlockingQueue）"><a href="#工作队列（BlockingQueue）" class="headerlink" title="工作队列（BlockingQueue）"></a>工作队列（BlockingQueue<Runnable>）</h1><p>首先，来看一下该属性的定义：</p>
<blockquote>
</blockquote>
<pre><code>/**
 * The queue used for holding tasks and handing off to worker
 * threads.  We do not require that workQueue.poll() returning
 * null necessarily means that workQueue.isEmpty(), so rely
 * solely on isEmpty to see if the queue is empty (which we must
 * do for example when deciding whether to transition from
 * SHUTDOWN to TIDYING).  This accommodates special-purpose
 * queues such as DelayQueues for which poll() is allowed to
 * return null even if it may later return non-null when delays
 * expire.
 */
private final BlockingQueue&lt;Runnable&gt; workQueue;
</code></pre>
<p>BlockingQueue就是在上一篇文中当中介绍到的阻塞队列。具体的实现类，则需要根据具体的业务场景以及其他的配置参数做出选择。从<a href="./../../26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%AE%80%E4%BB%8B/index.html">同步容器与并发容器类简介</a>中我们可以知道，阻塞队列可粗分为三类，无界队列，有界队列，以及同步移交（Synchronous Handoff）。对于无界队列，不存在队列的饱和情况，而对于游街队列及同步移交来说，当任务的数量大于固定队列的大小时，如果处理这部分对于的任务，则需要根据饱和策略来决定。</p>
<h1 id="饱和策略（RejectedExecutionHandler）"><a href="#饱和策略（RejectedExecutionHandler）" class="headerlink" title="饱和策略（RejectedExecutionHandler）"></a>饱和策略（RejectedExecutionHandler）</h1><p>当有界队列被填满后，饱和策略开始发挥作用。JDK提供了几种不同的RejectedExecutionHandler实现，每种实现都包含了不同的饱和策略：</p>
<ul>
<li>AbortPolicy<br>“中止”策略是默认的饱和策略。该策略将抛出未检查的RejectedExecutionException异常。</li>
<li>CallerRunsPolicy<br>“调用者运行”策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了excute的线程中执行该任务。</li>
<li>DiscardPolicy<br>当新提交的任务无法保存到队列中等待执行时，“抛弃（Discard）”策略会悄悄抛弃该任务。</li>
<li>DiscardOldestPolicy<br>“抛弃最旧的”策略会抛弃下一个将被执行的任务。</li>
</ul>
<h1 id="线程工厂（ThreadFactory）"><a href="#线程工厂（ThreadFactory）" class="headerlink" title="线程工厂（ThreadFactory）"></a>线程工厂（ThreadFactory）</h1><p>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成了。默认的线程工厂将创建一个新的，非守护的线程，并不包含特殊的配置信息。因此，当我没需要创建特殊的线程（不如在创建过程当中打印日志，给线程修改名字）时，就可以提供我们自己的线程工厂实例就可以了。自定义一个线程工厂很简单，只需要实现ThreadFactory接口即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new &#123;<span class="doctag">@code</span> Thread&#125;.  Implementations may also initialize</span></span><br><span class="line"><span class="comment">     * priority, name, daemon status, &#123;<span class="doctag">@code</span> ThreadGroup&#125;, etc.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r a runnable to be executed by new thread instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> constructed thread, or &#123;<span class="doctag">@code</span> null&#125; if the request to</span></span><br><span class="line"><span class="comment">     *         create a thread is rejected</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口只有一个函数，我们可以通过该函数，定制化我们自己的线程。<br>线程池的介绍就到这里，在程序代码中，强烈建议，不要显示地定义线程去执行任务，而是通过线程池来执行任务，防止不可预料的错误发生。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>java并发编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Jpa删除数据未成功原因分析</title>
    <url>/blog/2018/05/09/Jpa%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E6%9C%AA%E6%88%90%E5%8A%9F%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在使用JpaRepository接口进行数据的删除操作过程中发现，当首先使用自定义的deleteBy方法删除某一数据实体，然后再对该数据实体（删除ID的值）进行save时（deleteBy和save的调用是在同一个事务当中且为连续的调用），会发生数据库错误，根据log，知道是违反了唯一键约束。说明deleteBy并没有成功。但是如果在两个方法调用之间插入一个查询，则持久化能够成功。下面分析下原因。<br>自定义的deleteBy方法已经使用@Transactional以及@Modifying进行注解并且调用该函数的地方也使用了@Transactional进行注解，按理来说应该已经保证了deleteBy方法能够执行，那么为什么会失败呢？其实，由于Jpa底层默认使用的是Hiberanate框架来实现的，所以产生该问题的根源是在Hiberanate。首先，让我们先来看一张图：<br><img src="/blog/2018/05/09/Jpa%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E6%9C%AA%E6%88%90%E5%8A%9F%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96.png" alt="数据持久化"><br>其实，在内存中，有一份Hiberanate进行管理的<code>缓存</code>。我们调用Jpa进行deleteBy时，其实是作用在这部分缓存上的，并没有真正地写到数据库当中。Hibernate会尽量将与数据库的操作延迟，直到必须要与数据库进行交互，例如save方法一般会在提交时才真正执行，最终在提交时会以批处理的方式与数据库进行交互，以提高效率。而将操作延迟，就是利用缓存，将最后要处理的操作放到缓存中。<br>因此，如果要将缓存中的数据持久化到数据库中，则需要调用JpaRepository的flush()方法（内部调用了EntityManager的flush()方法）来完成，flush方法的主要作用就是清理缓存，强制数据库与Hibernate缓存同步，以保证数据的一致性。但即使调用了该函数，数据也还是没有持久化到数据库中。这是因为，前面也提到过，deleteBy和save的调用是在同一个事务当中，而根据Hibernate的机制，flush()方法进行清理缓存的操作,它的主要动作就是向数据库发送一系列的sql语句，并执行这些sql语句，但是不会向数据库提交。而只有到将事务进行提交时，数据库才会去执行这些SQL，将数据持久化到数据库中。因此，即使在事务过程当中调用了flush()方法，也无法保证数据被持久化。而之所以加上查询后能够进行持久化，就是因为，执行查询时，会首先将事务进行提交才执行查询，因此deleteBy才成功了。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>spring springboot jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务处理</title>
    <url>/blog/2018/05/14/Spring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在讲解Spring中使用事务管理之前，首先让我们来看下什么是事务。</p>
<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><p>一个数据库事务通常包含了一个序列的对数据库的读&#x2F;写操作。它的存在包含有以下两个目的：</p>
<ol>
<li>为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。</li>
<li>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。<br>当事务被提交给了DBMS（数据库管理系统），则DBMS（数据库管理系统）需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被<code>回滚</code>，回到事务执行前的状态;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。</li>
</ol>
<h2 id="事务的四个特性"><a href="#事务的四个特性" class="headerlink" title="事务的四个特性"></a>事务的四个特性</h2><p>数据库事务拥有以下四个特性，习惯上被称之为ACID特性:</p>
<ol>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</li>
<li>持久性（Durability）：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ol>
<h2 id="事务的隔离"><a href="#事务的隔离" class="headerlink" title="事务的隔离"></a>事务的隔离</h2><p>当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。</p>
<h3 id="虚读-幻读"><a href="#虚读-幻读" class="headerlink" title="虚读(幻读)"></a>虚读(幻读)</h3><p>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>数据库为我们提供的四种隔离级别：</p>
<ol>
<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生</li>
<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生</li>
<li>Read committed (读已提交)：可避免脏读的发生</li>
<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证</li>
</ol>
<h2 id="Spring中事务级别"><a href="#Spring中事务级别" class="headerlink" title="Spring中事务级别"></a>Spring中事务级别</h2><p>在SpringBoot中，要使用事务，方法很简单，这里我们以Jpa为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public interface FdmtMoItemRepository extends JpaRepository&lt;FdmtMoItem, Integer&gt; &#123;</span><br><span class="line">    void deleteByItemIdIn(List&lt;Long&gt; itemIds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义的interface中，需要为类或者函数上加上@Transactional注解。打开@Transactional直接的源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface Transactional &#123;</span><br><span class="line">    @AliasFor(&quot;transactionManager&quot;)</span><br><span class="line">	String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">	String transactionManager() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    Propagation propagation() default Propagation.REQUIRED;</span><br><span class="line"></span><br><span class="line">    Isolation isolation() default Isolation.DEFAULT;</span><br><span class="line"></span><br><span class="line">    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;</span><br><span class="line"></span><br><span class="line">    boolean readOnly() default false;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] rollbackForClassName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] noRollbackForClassName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在注解中，上述函数的作用分别是：</p>
<ol>
<li>value transactionManager 用于设置事务管理器的名字</li>
<li>propagation 设置事务的传播机制。也就是，但需要进行事务操作的时候：<ul>
<li>PROPAGATION_REQUIRED 如果当前已经存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。</li>
<li>PROPAGATION_SUPPORTS 如果当前已经存在事务，那么加入该事务，否则创建一个所谓的空事务（可以认为无事务执行）。</li>
<li>PROPAGATION_MANDATORY 当前必须存在一个事务，否则抛出异常。</li>
<li>PROPAGATN_REQUIRES_NEW 如果当前存在事务，先把当前事务相关内容封装到一个实体，然后重新创建一个新事务，接受这个实体为参数，用于事务的恢复。更直白的说法就是暂停当前事务(当前无事务则不需要)，创建一个新事务。 针对这种情况，两个事务没有依赖关系，可以实现新事务回滚了，但外部事务继续执行。</li>
<li>NOT_SUPPORTED 如果当前存在事务，挂起当前事务，然后新的方法在没有事务的环境中执行，没有spring事务的环境下，sql的提交完全依赖于 defaultAutoCommit属性值 。</li>
<li>PROPAGATION_NEVER 如果当前存在事务，则抛出异常，否则在无事务环境上执行代码。</li>
<li>PROPAGATION_NESTED 如果当前存在事务，则使用 SavePoint 技术把当前事务状态进行保存，然后底层共用一个连接，当NESTED内部出错的时候，自行回滚到 SavePoint这个状态，只要外部捕获到了异常，就可以继续进行外部的事务提交，而不会受到内嵌业务的干扰，但是，如果外部事务抛出了异常，整个大事务都会回滚。</li>
</ul>
</li>
<li>isolation  设置事务的隔离级别，也就是对应了上面提到的数据库的几个事务隔离级别<ul>
<li>DEFAULT 使用数据库设置的隔离级别 ( 默认 ) ，由 DBA 默认的设置来决定隔离级别。</li>
<li>SERIALIZABLE 保证所有的情况不会发生（锁表）</li>
<li>REPEATABLE_READ 会出幻读（锁定所读取的所有行）。</li>
<li>READ_COMMITTED  会出现不可重复读、幻读问题（锁定正在读取的行）。</li>
<li>READ_UNCOMMITTED 会出现脏读、不可重复读、幻读 ( 隔离级别最低，并发性能高 )。</li>
</ul>
</li>
<li>timeout 设置事务的超时时间</li>
<li>readOnly 设置是否为只读事务</li>
<li>rollbackFor 设置事务在法身什么异常的情况下进行回滚</li>
<li>rollbackForClassName 设置当发生对应名字的异常时进行回滚</li>
<li>noRollbackFor 设置发生什么异常的情况下不回滚</li>
<li>noRollbackForClassName 设置当发生对应名字的异常时进行不回滚</li>
</ol>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring 事务</tag>
      </tags>
  </entry>
  <entry>
    <title>elk基于SpringBoot的二次开发</title>
    <url>/blog/2018/05/16/%E5%9F%BA%E4%BA%8Eelk%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h1><p>ELK是由Elasticsearch、Logstash、Kibana三部分组成：</p>
<ol>
<li>Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。</li>
<li>Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。</li>
<li>Kibana 也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。<br>在大多数情况下，我们都是使用ELK来进行日志的收集及分析工作，直接在Kibana中查看数据信息。那么，如果我们需要利用ELK的能力进行二次开发的话，就需要使用net.logstash.logback来完成我们的需求。有关ELK的部署读者可以参考其他的文章来完成，本文重点介绍在SpringBoot中操作ELK数据的方法及过程。</li>
</ol>
<p><img src="/blog/./kibana%E6%95%88%E6%9E%9C%E5%9B%BE.PNG" alt="kibana效果图.PNG"></p>
<h1 id="SpringBoot中使用ELK"><a href="#SpringBoot中使用ELK" class="headerlink" title="SpringBoot中使用ELK"></a>SpringBoot中使用ELK</h1><ol>
<li>添加依赖<br>要在SpringBoot中使用ELK，需要添加依赖：<br>compile group: ‘com.github.vanroy’, name: ‘spring-boot-starter-data-jest’, version: ‘3.0.0.RELEASE’<br>在该包中，有我们操作ELK所需要的接口。</li>
<li>配置ELK路径<br>在SpringBoot的配置文件当中，配置ELK的路径：spring.data.jest.uri     &#x3D; <a href="http://ipaddress:9200/">http://ipAddress:9200</a></li>
<li>注入JestClient对象<br>在需要使用到ELK的模块中，注入JestClient对象，建议实现一个公共的接口，提供ELK功能，这样只需要在该代码中进行一次注入即可：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private JestClient jestClient;</span><br></pre></td></tr></table></figure>
接下来，就可以使用jestClient操作ELK的数据了。下面我们将来看看如何通过JestClient操作ELK。</li>
</ol>
<h1 id="JestClient操作ElasticSearch数据"><a href="#JestClient操作ElasticSearch数据" class="headerlink" title="JestClient操作ElasticSearch数据"></a>JestClient操作ElasticSearch数据</h1><p>ElasticSearch使用查询表达是来进行数据的检索。查询表达式(Query DSL)是一种非常灵活又富有表现力的查询语言。Elasticsearch 使用它可以以简单的JSON接口来展现Lucene功能的绝大部分。在应用中，用它来编写查询语句。它可以使查询语句更灵活、更精确、易读和易调试。要使用这种查询表达式，只需将查询语句传递给 query 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /my_store/products</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: YOUR_QUERY_HERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，ElasticSearch中的其他操作，也是使用类似于该表达式的方式来操作的，比如，添加记录的的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /my_store/products/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 10, &quot;productID&quot; : &quot;XHDK-A-1293-#fJ3&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 20, &quot;productID&quot; : &quot;KDKE-B-9947-#kL5&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 3 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 30, &quot;productID&quot; : &quot;JODL-X-1937-#pV7&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 4 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 30, &quot;productID&quot; : &quot;QQPX-R-3956-#aD8&quot; &#125;</span><br></pre></td></tr></table></figure>
<p>关于ElasticSearch的DSL语言部分，有机会的话会单独写一篇文章来总结下，这里只做一个简单的介绍。重要的是，如何通过JestClient来操作ElasticSearch。我们以一个简单的查询操作来看下：</p>
<ol>
<li>构建过滤条件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BoolQueryBuilder queryBuilder = boolQuery().must(termQuery(&quot;dataId.id&quot;, 2101987));</span><br><span class="line">queryBuilder.must(termQuery(&quot;dataId.dataSetId&quot;, QueryParser.escape(fdmt_main_oper_item)));</span><br><span class="line">queryBuilder.must(termQuery(&quot;operator&quot;, operator));</span><br></pre></td></tr></table></figure></li>
<li>将条件对象转换位条件语句：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String queryString = new SearchSourceBuilder().query(queryBuilder).toString();</span><br></pre></td></tr></table></figure></li>
<li>使用条件语句进行查询：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Search search = new Search.Builder(queryString).addIndex(DATA_LIFECYCLE_INDEX).addType(DATA_LIFECYCLE_TYPE).build();</span><br><span class="line">SearchResult result = jestClient.execute(search);</span><br></pre></td></tr></table></figure>
来看下第二步操作获取到的字符串：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;bool&quot; : &#123;</span><br><span class="line">      &quot;must&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot; : &#123;</span><br><span class="line">            &quot;dataId.id&quot; : &#123;</span><br><span class="line">              &quot;value&quot; : &quot;2101987&quot;,</span><br><span class="line">              &quot;boost&quot; : 1.0</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot; : &#123;</span><br><span class="line">            &quot;dataId.dataSetId&quot; : &#123;</span><br><span class="line">              &quot;value&quot; : &quot;fdmt_main_oper_item&quot;,</span><br><span class="line">              &quot;boost&quot; : 1.0</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;disable_coord&quot; : false,</span><br><span class="line">      &quot;adjust_pure_negative&quot; : true,</span><br><span class="line">      &quot;boost&quot; : 1.0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从结构中可以看出，这正是ElasticSearch结构化查询表达式的后半部分，那么，只要把前半部分补充上，不久可以进行查询了吗。而：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Search.Builder(queryString).addIndex(DATA_LIFECYCLE_INDEX).addType(DATA_LIFECYCLE_TYPE)；</span><br></pre></td></tr></table></figure>
所做的操作，也就是补全查询表达的查询路径而已。<br>接下来我们看看JestClient的execute接口做的操作。在JestClient接口的实现JestHttpClient中，可以看到：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">JestResult</span>&gt; T <span class="title function_">execute</span><span class="params">(Action&lt;T&gt; clientRequest, RequestConfig requestConfig)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">HttpUriRequest</span> <span class="variable">request</span> <span class="operator">=</span> prepareRequest(clientRequest, requestConfig);</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = executeRequest(request);</span><br><span class="line">            <span class="keyword">return</span> deserializeResponse(response, request, clientRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HttpHostConnectException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CouldNotConnectException</span>(ex.getHost().toURI(), ex);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Exception occurred while closing response stream.&quot;</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
execute接口所做的工作，就是发起Http请求，根据url去访问ElasticSearch。由此我们可以看出，使用JestClient来操作ElasticSearch其实很简单，重要的是将ElasticSearch的Restful风格的操作接口构建出来，而ElasticSearch中的所使用到的相关的关键字，都有对应的函数实现。在上面查询条件的构造当中，我们使用了boolQuery(),其在ElasticSearch的结构化查询语言中其实就是对应着<code>&quot;bool&quot; : &#123;&#125;</code>。boolQuery()方法返回的是一个BoolQueryBuilder的对象，该类继承自AbstractQueryBuilder抽象类，在该抽象类下，有多大几十个的子类：<br><img src="/blog/2018/05/16/%E5%9F%BA%E4%BA%8Eelk%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6.PNG" alt="查询条件.PNG"><br>这些子类都对应着ElasticSearch中的某一个关键字，具体的大家可以打看IDEA查看下抽象类的具体子类。<br>至此，在SringBoot中操作ElasticSearch的的步骤及方法大致清楚了,关于c查询结果SearchResult，大致也是存在着与查询：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /my_store/products</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: YOUR_QUERY_HERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
的结果的对应关系，具体的可以看文档中介绍了。</li>
</ol>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>SpringBoot elk</tag>
      </tags>
  </entry>
  <entry>
    <title>获取任务执行结果之Future原理</title>
    <url>/blog/2018/07/11/%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%B9%8BFuture%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>由于在开发过程当中需要获取线程执行的结果，故使用到了Java并发工具包<code>java.util.concurrent</code>下的Future类，最终通过Future的get来获取到线程执行的结果。这里我们来简单解析下，Future的实现原理及使用方式。</p>
<p>Java提供了两个自定义线程的底层接口，一个是Runnable接口一个是Callable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过比较可以看出，Runnable接口的run函数返回时为Void，而Callable的call函数返回值为V，也就是通过泛型传入的类型参数，由此也就为获取线程执行结果提供了实现的支持。线程的执行我们一般通过交由线程池ThreadPoolExecutor来完成。在该类中，我们有多种提交任务的方式，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span><span class="params">(...)</span></span><br></pre></td></tr></table></figure>
<p>在ThreadPoolExecutor的父类AbstractExecutorService中，还提供了几个提交任务的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个函数中，都通过将Runable或Callable包装成RunnableFuture，并交由线程池来执行，那么来看下RunnableFuture的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口提供了两个功能，一个是继承Runnable接口提供了任务的运行功能，一个是继承Future接口，用于获取执行结果。接下来我们看下该处使用的RunnableFuture的具体实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a &#123;<span class="doctag">@code</span> RunnableFuture&#125; for the given callable task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callable the callable task being wrapped</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the callable&#x27;s result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> RunnableFuture&#125; which, when run, will call the</span></span><br><span class="line"><span class="comment"> * underlying callable and which, as a &#123;<span class="doctag">@code</span> Future&#125;, will yield</span></span><br><span class="line"><span class="comment"> * the callable&#x27;s result as its result and provide for</span></span><br><span class="line"><span class="comment"> * cancellation of the underlying task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应Runnable和Callable入参，创建FutureTask。其中由于Runnable是没有返回值的，由第一个函数的javadoc可知，我们可以传递一个T类型的value值，当任务执行完毕时，将会返回该value。<br>由此，我们大概可以推测出能获取执行结果的任务是如何执行的。首先，通过ThreadPoolExecutor的submit函数提交一个实现了Callable接口或者Runnable接口的实现类给线程池，线程池会将该任务包装成一个RunnableFuture对象（实现了Future接口及Runnable接口），并将该对象提交线程池执行，并返回该对象。在最外层，就可以通过Future的get()来获取线程的执行结果了。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PdfReaderCallable pdfReaderCallable = new PdfReaderCallable(url);</span><br><span class="line">Future&lt;String&gt; task = pdfReadExecutor.submit(pdfReaderCallable);</span><br><span class="line">String result = task.get();</span><br></pre></td></tr></table></figure>
<p>其中PdfReaderCallable实现了Callable接口，pdfReadExecutor为线程池实现类。当执行该逻辑的线程执行了到第三条语句的时候，将被阻塞，一直等到task.get()返回结果才会继续向下执行。<br>接下来，让我们更深入地来看一下最终提交给线程池执行的FutureTask的实现原理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line">    <span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.callable = callable;</span><br><span class="line">        <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="type">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="literal">null</span>;</span><br><span class="line">                    ran = <span class="literal">false</span>;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V v)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            outcome = v;</span><br><span class="line">            UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只列举了几个比较重要的成员变量及成员函数。通过构造函数可以看出，成员变量callable是实际的任务类。在FutureTask的run方法中最终调用了该实际任务类来执行任务并获取结果result，最后调用set函数将result赋值给outcome对象。而在外部，我们通过get()函数来获取结果，如果任务含没有执行完，那么将会通过awaitDone函数阻塞，一直等待任务执行完毕，才能继续执行并最终通过report函数返回执行结果。<br>至此，获取任务执行结果的Future实现就分析结束。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>java并发编程</category>
      </categories>
      <tags>
        <tag>java并发编程 Future</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP基础————动态代理简介</title>
    <url>/blog/2018/08/11/AOP%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>AOP最为Spring的一大核心卖点，在开发当中经常使用到。对于切面、切点的定义我们可能很熟悉，但是对于实现该技术的底层技术细节，却知之甚少。利用周末的时间，博主将AOP的底层实现细节研究了一下，在此做为记录。</p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP是Aspect Oriented Programing的简称，可译为“面向切面编程”。在业务实现过程当中，有很多横切面上的业务是存在共通之处的，比如，在每一个业务模块的入口，需要打印业务开始的日志信息，在完成业务后需要打印业务调用耗时，对于这些共通的业务，由于不能通过多态继承的方式来实现，会导致很多相似代码出现在不同的业务逻辑当中，AOP就是为了解决这些问题而存在的。下面让我们来一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ForumService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeTopic</span><span class="params">(<span class="type">int</span> topidId)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createForum</span><span class="params">(Forum forum)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForumServiceImpl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TransactionManager transManager;</span><br><span class="line">    <span class="keyword">private</span> PerformanceMotitor pmonitor;</span><br><span class="line">    <span class="keyword">private</span> TopicDao topicDao;</span><br><span class="line">    <span class="keyword">private</span> ForumDao forumDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeTopic</span><span class="params">(<span class="type">int</span> topidId)</span> &#123;</span><br><span class="line">        pmomitor.start();</span><br><span class="line">        transManager.beginTransaction();</span><br><span class="line">        topicDao.remove(topidId);</span><br><span class="line">        transManager.commit();</span><br><span class="line">        pmonitor.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createForum</span><span class="params">(Forum forum)</span> &#123;</span><br><span class="line">        pmomitor.start();</span><br><span class="line">        transManager.beginTransaction();</span><br><span class="line">        forumDao.create(forum);</span><br><span class="line">        pmonitor.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该类的两个方法中，存在共通的逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pmomitor.start();</span><br><span class="line">transManager.beginTransaction();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pmonitor.end();</span><br></pre></td></tr></table></figure>
<p>若没有办法将这些共通的代码提炼出来，则会在业务逻辑中产生大量重新性的代码（该例子虽然可以提取公共逻辑到一个辅助函数中来解决，但是很多公共领域内如事务的开启与关闭并不是要业务逻辑所关心的，而是应该有基础的框架来为客户提供）。那么如何解决这种问题呢？其实最简单的方法便是在调用这些业务方法之前，对调用进行拦截，并执行公共的与业务无关的代码，然后再调用实际的业务逻辑。AOP就是基于这种思想来实现的。在设计模式当中，存在代理模式，而Spring中的AOP实现，便是基于这一设计模式来实现的。接下来让我们看一下，有关Spring中动态代理的一些相关介绍。</p>
<h1 id="Spring-AOP的核心基础——动态代理"><a href="#Spring-AOP的核心基础——动态代理" class="headerlink" title="Spring AOP的核心基础——动态代理"></a>Spring AOP的核心基础——动态代理</h1><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>从JDK1.3开始，Java为我们提供了动态代理技术，允许开发者在运行期间创建接口的动态代理实例。JDK的动态代理主要涉及到Java.lang.reflect中的两个类，一个是Proxy，一个是InvocationHander，InvocationHander是一个接口，可以通过该接口定义横切的公共逻辑，并通过反射机制来调用目标类的代码，动态地将横切逻辑与业务逻辑编织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerformanceHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        pmomitor.start();</span><br><span class="line">        transManager.beginTransaction();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        pmonitor.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForumServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ForumService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForumServiceImpl</span>();</span><br><span class="line">        <span class="type">PerformanceHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PerformanceHandler</span>(target);</span><br><span class="line">        <span class="type">ForumService</span> <span class="variable">proxy</span> <span class="operator">=</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler);</span><br><span class="line">        proxy.createForum(<span class="number">10</span>);</span><br><span class="line">        proxy.removeTopic(<span class="number">1012</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中，我们定义了一个横向的切面逻辑PerformanceHandler，其实现了InvocationHandler。利用Proxy.newProxyInstance函数创建出一个目标对象的代理对象proxy，当调用代理对象的createForum及removeTopic函数时，便会先执行pmomitor.start()和transManager.beginTransaction()，之后才执行目标对象真是的业务逻辑，最后执行pmonitor.end()。如此，也就完成了公共逻辑的提取。让我们看一下InvocationHandler接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口只有一个接口方法，参数分别为proxy——需要代理的目标对象，method——被拦截的目标对象的方法，args——方法参数。以及Proxy.newProxyInstance:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                          InvocationHandler h)</span> &#123;</span><br><span class="line">                                              ...</span><br><span class="line">                                          &#125;</span><br></pre></td></tr></table></figure>
<p>对于函数的逻辑暂时无需关心，重点是该函数的入参，loader——目标类的类加载器，interfaces——目标类实现的接口列表，h——调用处理器的实例。</p>
<h2 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h2><p>使用JDK的动态代理有一个限制，即它只能为接口创建代理实例，从Proxy的newProxyInstance方法入参就可以看出，第二个入参interfaces就是需要代理实例实现的接口列表。那么，对于不是interfaces的下接口的实例函数，是否就没有办法实现动态代理呢？CGLib作为一个替代者，填补了这项空缺。<br>CGLib采用底层的字节码技术，可以为一个类生成子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑，下面是采用CGLib技术编写的一个可以为任何类织入相关逻辑的代理对象的代理创建器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="comment">//通过字节码技术动态创建子类实例</span></span><br><span class="line">        enhancer.setSuperClass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        pmomitor.start();</span><br><span class="line">        transManager.beginTransaction();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        pmonitor.end();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForumServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line">        <span class="type">ForumService</span> <span class="variable">forumServiceProxy</span> <span class="operator">=</span> (ForumService) proxy.getProxy(ForumServiceImpl.class)</span><br><span class="line">        forumServiceProxy.createForum(<span class="number">10</span>);</span><br><span class="line">        forumServiceProxy.removeTopic(<span class="number">1012</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，用户可以通过getProxy方法为一个类创建动态代理对象，无论这个类中的函数是否是从接口实现而来还是类本身的函数，当调用getProxy返回的对象时，横切逻辑都能得到执行。<br>基于以上两个简单的例子，让我们来看一下Spring中实现动态代理的逻辑。</p>
<h2 id="Spring中代理的实现逻辑"><a href="#Spring中代理的实现逻辑" class="headerlink" title="Spring中代理的实现逻辑"></a>Spring中代理的实现逻辑</h2><p>在Spring中，动态代理的创建是在Bean实例化并初始化之后，调用的几个BeanPostProcessor中的进行的，这几个BeanPostProcessor后处理器分别是BeanNameAutoProxyCreator，DefaultAdvisorAutoProxyCreator以及AnnotationAwareAspectJAutoProxyCreator。这三个类都是AbstractAutoProxyCreator类的子类，在该抽象类中有一个保护方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">			AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">		proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">				proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">		proxyFactory.addAdvisors(advisors);</span><br><span class="line">		proxyFactory.setTargetSource(targetSource);</span><br><span class="line">		customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">		proxyFactory.setFrozen(<span class="built_in">this</span>.freezeProxy);</span><br><span class="line">		<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">			proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们重点看ProxyFactory proxyFactory &#x3D; new ProxyFactory();该函数使用了一个代理工厂生成目标类的代理，而ProxyFactory类的getProxy方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>中我们看到其调用了ProxyFacory父类ProxyCreatorSupport中的createAopProxy方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.active) &#123;</span><br><span class="line">			activate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>getAopProxyFactory放回的是一个AopProxyFactory接口的实例，而AopProxyFactory唯一的一个实例便是DefaultAopProxyFactory，其createAopProxy逻辑为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>从这个函数中我们可以看出，Spring使用了之前介绍的两种代理技术——JDK与CGLib，根据不同的条件，则会使用不同的代理技术来创建代理。其中，ObjenesisCglibAopProxy（继承自CglibAopProxy）使用类CgLib动态代理技术创建代理，而JdkDynamicAopProxy使用JDK动态代理技术创建代理。如果通过ProxyFactory的setInterfaces方法指定了目标接口进行代理，则ProxyFactory使用JdkDynamicAopProxy；如果是针对类的代理，则使用CglibAopProxy。此外，还可以通过ProxyFacory的setOptimize(true)方法让ProxyFactory启动优化代理方式，这样，针对接口的代理也会使用CglibAopProxy。</p>
<p>至此，我们介绍了Spring中AOP实现的基础——动态代理的原理以及Spring对两种代理技术的集成。可以看出，JDK的动态代理是基于组合模式的，其代理对象持有一个目标类的实例。而CGLib则是利用字节码技术，基于继承实现的动态代理子类。本文没有介绍具体的AOP的使用方式，重点是介绍AOP的底层实现细节。由于AOP的使用方式介绍起来篇幅过大，有机会的话一定会好好总结下～</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat服务器结构浅析（一）</title>
    <url>/blog/2018/09/02/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>最近有点懒，博客更新少，补上一篇之前的欠债。。。这篇博客内容基于《Tomcat架构解析》,这里把Tomcat主要的结构介绍了下，更详细的内容大家可以参考该书。</p>
<p>Tomcat是全世界最著名的基于Java语言的轻量级应用服务器，是一款完全开源免费的Servlet容器实现。同时，它支持HTML，JS等静态资源的处理，因此也可作为轻量级的WEB服务器来使用。在以前的WEB开发当中，我们主要通过将程序打包，将打包文件放到webapps下来进行访问，而在使用SpringBoot作为开发框架的情况下，由于SpringBoot已内嵌Tomcat，不需要将打包文件放在特定的文件夹下，而是直接运行程序即可。这篇博客第一部分内容将介绍Tomcat的整体架构，第二部分介绍SpringBoot内嵌Tomcat的实现。</p>
<h1 id="Tomcat总体架构"><a href="#Tomcat总体架构" class="headerlink" title="Tomcat总体架构"></a>Tomcat总体架构</h1><p>首先，让我们来看一张图：<br><img src="/blog/2018/09/02/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/Tomcat%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84.PNG" alt="Tomcat应用服务器"><br>Tomcat总体的设计便是围绕着这张图来的。下面我们依次对上图中的各个部分做一下介绍。</p>
<h2 id="Lifecycle-接口"><a href="#Lifecycle-接口" class="headerlink" title="Lifecycle 接口"></a>Lifecycle 接口</h2><p>该接口主要定义了容器整个生命周期过程中的各个阶段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口包含了容器初始化，开始，停止，销毁等过程。其实现类的各个组件在容器的工作过程当中需要做的工作，即在这几个函数中来完成。</p>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>表示整个Servlet容器，因此Tomcat运行环境中只有唯一一个Server实例。在该接口的唯一实现类StandardServer中，除了表示Service的一个对象数组外，主要是一些关于Tomcat的属性，比如port，address等。该容器的这些属性，可以通过properties文件或者yaml文件进行配置（比如端口通过server.port&#x3D;8080进行配置），或者是原来的开发方式，通过Server.xml进行配置。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service表示一个或者多个Connector的集合，这些Connector共享同一个Container（即Engine）来处理其请求。在同一个Tomcat实例内可以包含任意多个Service实例，它们彼此独立。Service其实是作为Tomcat中接收请求，以及处理请求的容器的纽带存在的。tomcat中的实现类StandardService有以下几个重要的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardService</span> <span class="keyword">extends</span> <span class="title class_">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Connector connectors[] = <span class="keyword">new</span> <span class="title class_">Connector</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Engine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Mapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mapper</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server表示其所属Server，Engine作为处理该service中Connector的容器。Mapper可以看作是映射器，要来处理请求地址到处理该请求的容器及Servlet的映射。</p>
<h2 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h2><p>在Tomcat中，Engine为最高层级的容器对象。尽管Engine不是直接处理请求的容器，却是获取目标容器的入口。</p>
<h2 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h2><p>Host 作为一类容器，表示Servlet引擎(Engine) 中的虚拟机， 与一个服务器的网络名有关，如域名等。客户端可以使用这个网络名连接服务器，这个名称必须要在DNS服务器上注册</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context作为一类容器，用于表示ServetContext ，在Servlet规范中， 一个ServletContext表示一个独立的Web应用</p>
<h2 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h2><p>Wrapper作为一类容器， 用于表示Web应用中定义的Servlet（其实是对Servlet进行了一层封装）。</p>
<h2 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h2><p>表示Tomcat中的链接器，其主要作用是监听并转化Socket请求，并交由Container处理。其实就是对不同协议及协议处理器进行的封装。下面是我们需要关注的几个属性域：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Connector</span> <span class="keyword">extends</span> <span class="title class_">LifecycleMBeanBase</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ProtocolHandler protocolHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service是其父容器，ProtocolHandler表示协议处理器</p>
<h2 id="ProtocolHandler"><a href="#ProtocolHandler" class="headerlink" title="ProtocolHandler"></a>ProtocolHandler</h2><p>ProtocolHandler表示协议处理器,是一个接口，其实现类有以下几种：<br><img src="/blog/2018/09/02/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/ProtocolHandler%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1.PNG" alt="ProtocolHandler继承层次"><br>从图中我们大概能够猜到，其中的每一个实现类，其实都代表着一种I&#x2F;O协议的处理过程，我们以同步非阻塞I&#x2F;O的处理器Http11NioProtocol为例，其最初继承于抽象类AbstractProtocol，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractProtocol</span>&lt;S&gt; <span class="keyword">implements</span> <span class="title class_">ProtocolHandler</span>,</span><br><span class="line">        MBeanRegistration &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> AbstractEndpoint&lt;S&gt; endpoint;</span><br><span class="line">            <span class="keyword">private</span> Handler&lt;S&gt; handler;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Processor&gt; waitingProcessors =  Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Processor, Boolean&gt;());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>AbstractEndpoint代表的是协议端点，比如，Nio使用的是NioEndpoint类，即为nio的实现逻辑，对nio类型的Socket进行监听， Handler作为AbstractEndpoint接收到I&#x2F;O后，用来处理I&#x2F;O的处理器。</p>
<h1 id="请求处理过程"><a href="#请求处理过程" class="headerlink" title="请求处理过程"></a>请求处理过程</h1><p>当我们的浏览器或者是其他工具发起一个Http请求时候，Tomcat的整个处理过程如下：<br><img src="/blog/2018/09/02/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86.PNG" alt="Tomcat请求处理"><br>从一开始的Endpoint监听到Http请求后，调用Processor进行处理，Process调用CoyoteAdapter进行处理，CoyoteAdapter通过Mapper获取到处理该请求的顶级容器Engine，通过一层层的查找，最终获取到处理该请求的Wrapper，经过Tomcat中定义的一系列过滤器（Filter）后，最终由Servlet（在SpringMVC中，便是被DispatcherServlet）进行了消费。Tomcat整个处理的流程便是这样的。</p>
<h1 id="SpringBoot内嵌Tomcat"><a href="#SpringBoot内嵌Tomcat" class="headerlink" title="SpringBoot内嵌Tomcat"></a>SpringBoot内嵌Tomcat</h1><p>再完成了Tomcat简单的解析之后，我们还要问，在启动SpringBoot应用的过程当中，是如何启动Tomcat的呢？在Tomcat中，其已经为我们提供了一个表示其实例的Tomcat类，通过查找，我们知道，该类的实例是在TomcatEmbeddedServletContainerFactory类的getEmbeddedServletContainer函数中被创建的。启动一个简单的SpringBoot应用，通过断点，我们能够看到它被调用的路径：<br><img src="/blog/2018/09/02/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/Tomcat%E5%90%AF%E5%8A%A8.PNG" alt="Tomcat启动"><br>从上图可知，到Springboot应用刷新容器的时候，会在该过程当中创建Tomcat的实例，我们来下看下函数的实现过程:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatEmbeddedServletContainerFactory</span></span><br><span class="line">		<span class="keyword">extends</span> <span class="title class_">AbstractEmbeddedServletContainerFactory</span> <span class="keyword">implements</span> <span class="title class_">ResourceLoaderAware</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> EmbeddedServletContainer <span class="title function_">getEmbeddedServletContainer</span><span class="params">(</span></span><br><span class="line"><span class="params">			ServletContextInitializer... initializers)</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Tomcat的实例</span></span><br><span class="line">		<span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为Tomcat设置应用的根目录</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">baseDir</span> <span class="operator">=</span> (<span class="built_in">this</span>.baseDirectory != <span class="literal">null</span> ? <span class="built_in">this</span>.baseDirectory</span><br><span class="line">				: createTempDir(<span class="string">&quot;tomcat&quot;</span>));</span><br><span class="line">		tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据Springboot使用的I/O协议，创建Connector，默认的协议是`String DEFAULT_PROTOCOL = &quot;org.apache.coyote.http11.Http11NioProtocol`,及NIO协议（同步非常阻塞）</span></span><br><span class="line">		<span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="built_in">this</span>.protocol);</span><br><span class="line">        <span class="comment">// 为Service添加Connector，若Tomcat还没有Service，则getService函数中会创建</span></span><br><span class="line">		tomcat.getService().addConnector(connector);</span><br><span class="line">		customizeConnector(connector);</span><br><span class="line">		tomcat.setConnector(connector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过配置autoDeploy禁止虚拟主机自动部署Web应用</span></span><br><span class="line">		tomcat.getHost().setAutoDeploy(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置Tomcat的顶级容器Engine</span></span><br><span class="line">		configureEngine(tomcat.getEngine());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加额外的自定义协议的Connector</span></span><br><span class="line">		<span class="keyword">for</span> (Connector additionalConnector : <span class="built_in">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">			tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置虚拟主机Host，其内会进一步初始化Host的字容器</span></span><br><span class="line">		prepareContext(tomcat.getHost(), initializers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对Tomcat进行包装，返回TomcatEmbeddedServletContainer的实例</span></span><br><span class="line">		<span class="keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于Tomcat的内容其实还有很多，只是由于时间限制，不能在这里更深入地讲解，若后期有机会，会继续更加深入地介绍Tomcat的各个组件，这篇内容就做为Tomcat容器系列的第一篇吧～</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8函数式编程</title>
    <url>/blog/2018/09/09/JDK8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>开发当中一直都有在使用函数式编程，尤其是在Stream类时，今天就来对jdk8中的函数式编程来做一个学习汇总。<br>我们最常用的面向对象编程（Java）属于命令式编程（Imperative Programming）这种编程范式。常见的编程范式还有逻辑式编程（Logic Programming），函数式编程（Functional Programming）。函数式编程作为一种编程范式，在科学领域，是一种编写计算机程序数据结构和元素的方式，它把计算过程当做是数学函数的求值，而避免更改状态和可变数据。</p>
<h1 id="Lambda-表达式的形式"><a href="#Lambda-表达式的形式" class="headerlink" title="Lambda 表达式的形式"></a>Lambda 表达式的形式</h1><p>在介绍函数式编程之前，让我们来看一下jdk8中提供的Lambda表达式的五种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.</span><br><span class="line">Runnable noArguments = () -&gt; System.out.println(&quot;Hello World&quot;);</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">ActionListener oneArgument = event -&gt; System.out.println(&quot;button clicked&quot;);</span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line">Runnable multiStatement = () -&gt; &#123;</span><br><span class="line">    System.out.print(&quot;Hello&quot;);</span><br><span class="line">    System.out.println(&quot; World&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">4.</span><br><span class="line">BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;</span><br><span class="line"></span><br><span class="line">5.</span><br><span class="line">BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y;</span><br></pre></td></tr></table></figure>
<p>1中所示的 Lambda表达式不包含参数,使用空括号 () 表示没有参数。该 Lambda 表达式 实现了 Runnable 接口,该接口也只有一个 run 方法,没有参数,且返回类型为void。2中所示的Lambda表达式包含且只包含一个参数,可省略参数的括号。Lambda表达式的主体不仅可以是一个表达式,而且也可以是一段代码块,使用大括号 ({})将代码块括起来,如3所示。该代码块和普通方法遵循的规则别无二致,可以用返回或抛出异常来退出。只有一行代码的Lambda表达式也可使用大括号,用以明确Lambda表达式从何处开始、到哪里结束。Lambda表达式也可以表示包含多个参数的方法,如4所示。这时就有必要思考怎样去阅读该Lambda 表达式。这行代码并不是将两个数字相加,而是创建了一个函数,用来计算两个数字相加的结果。变量add的类型是BinaryOperator。当需要限定使用该Lambda表达式的使用范围，比如说只能传递Long型的参数时，则可以将参数具体化为Long型，如5。<br>我们以Spring中创建一个自定义的事件监听器为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Handle an application event.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(E event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationListener 只有一个抽象方法：actionPerformed，被用来表示行为:接受一个参数，返回空。当我们要自定义一个自己的ApplicationListener时，可以通过匿名内部列的形式实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(App.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ApplicationListener <span class="title function_">newApplicationListener</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;create a ApplicationListener&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApplicationListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;process event&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，还可以使用上文提到的Lambda表达式的形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(App.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ApplicationListener <span class="title function_">newApplicationListener</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;create a ApplicationListener&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> event -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;process event&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个限制是，<code>函数接口里面只能有一个抽象方法</code>。</p>
<h1 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h1><p>其实在上一节当中，我们已经使用了函数接口。jdk中为我们提供了@FunctionalInterface注解，该注解的作用是，当我们对一个接口进行标注时，编译器会检查该接口是否只用一个抽象方法。也就是说，即使我们的接口不标注该注解，只要满足接口只有一个抽象函数的要求，就是一个函数接口。ApplicationListener就是一个函数接口。</p>
<p>JDK8中提供了一组常用的核心函数接口：</p>
<table>
<thead>
<tr>
<th align="center">接口</th>
<th align="center">参数</th>
<th align="center">返回类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Predicate<T></td>
<td align="center">T</td>
<td align="center">boolean</td>
<td align="center">用于判别一个对象。比如求一个人是否为男性</td>
</tr>
<tr>
<td align="center">Consumer<T></td>
<td align="center">T</td>
<td align="center">void</td>
<td align="center">用于接收一个对象进行处理但没有返回，比如接收一个人并打印他的名字</td>
</tr>
<tr>
<td align="center">Function&lt;T, R&gt;</td>
<td align="center">T</td>
<td align="center">R</td>
<td align="center">转换一个对象为不同类型的对象</td>
</tr>
<tr>
<td align="center">Supplier<T></td>
<td align="center">None</td>
<td align="center">T</td>
<td align="center">提供一个对象</td>
</tr>
<tr>
<td align="center">UnaryOperator<T></td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">接收对象并返回同类型的对象</td>
</tr>
<tr>
<td align="center">BinaryOperator<T></td>
<td align="center">(T, T)</td>
<td align="center">T</td>
<td align="center">接收两个同类型的对象，并返回一个原类型对象</td>
</tr>
</tbody></table>
<p>除此之外，还有其他一些很多的函数接口，这些接口都在java.util.function包下<br><img src="/blog/2018/09/09/JDK8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3.PNG" alt="函数接口"><br>任意点开一个接口，我们都可以发现，该接口只会有一个抽象函数，0个或者多个default函数。<br>在大多数场景中，我们使用函数接口进行编程主要是在Stream中，打开Stream的类可以发现，该类的方法参数很多都是使用到了函数接口,以Stream类foreach为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        stringList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        stringList.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        stringList.stream().forEach((value) -&gt; &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其实质是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        stringList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        stringList.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Consumer&lt;String&gt; stringConsumer = (value) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;value is : &quot;</span> + value);</span><br><span class="line">        &#125;;</span><br><span class="line">        stringList.stream().forEach(stringConsumer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>在使用Stream的过程中，我们也许还会见到下面这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(App.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Lists.newArrayList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxInt</span> <span class="operator">=</span> list.stream()</span><br><span class="line">                .max(Integer::compareTo)</span><br><span class="line">                .get();</span><br><span class="line">        assertEquals(maxInt, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list2 = Lists.newArrayList(-<span class="number">3</span>, <span class="number">5</span>, -<span class="number">2</span>, <span class="number">9</span>, -<span class="number">1</span>);</span><br><span class="line">        assertEquals(list2.stream().map(Math::abs).allMatch(e -&gt; e &gt; <span class="number">0</span>), <span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        Comparator&lt;Person&gt; comparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge().compareTo(o2.getAge());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        List&lt;Person&gt; PersonList = Lists.newArrayList(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;teny&quot;</span>,<span class="number">23</span>), <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tome&quot;</span>,<span class="number">55</span>));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">minAgePerson</span> <span class="operator">=</span> PersonList.stream()</span><br><span class="line">                .min(comparator::compare)</span><br><span class="line">                .get();</span><br><span class="line">        assertEquals(minAgePerson.getAge(), <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">newPerson</span> <span class="operator">=</span> Person.createPerson(Person::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">createPerson</span><span class="params">(Supplier&lt;Person&gt; supplier)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> supplier.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.age = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Integer::compareTo</code>也是属于Java8引入的新特性，叫做方法引用（Method References），其实就是 (int1, int2) -&gt; int1.compareTo(int2) 的简写。<br>引用方法有下面几种方式</p>
<h2 id="对象引用-实例方法名"><a href="#对象引用-实例方法名" class="headerlink" title="对象引用::实例方法名"></a>对象引用::实例方法名</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge().compareTo(o2.getAge());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        List&lt;Person&gt; PersonList = Lists.newArrayList(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;teny&quot;</span>,<span class="number">23</span>), <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tome&quot;</span>,<span class="number">55</span>));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">minAgePerson</span> <span class="operator">=</span> PersonList.stream()</span><br><span class="line">                .min(comparator::compare)</span><br><span class="line">                .get();</span><br><span class="line">        assertEquals(minAgePerson.getAge(), <span class="number">23</span>);</span><br></pre></td></tr></table></figure>

<h2 id="类名-静态方法名"><a href="#类名-静态方法名" class="headerlink" title="类名::静态方法名"></a>类名::静态方法名</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list2 = Lists.newArrayList(-<span class="number">3</span>, <span class="number">5</span>, -<span class="number">2</span>, <span class="number">9</span>, -<span class="number">1</span>);</span><br><span class="line">        assertEquals(list2.stream().map(Math::abs).allMatch(e -&gt; e &gt; <span class="number">0</span>), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="类名-实例方法名"><a href="#类名-实例方法名" class="headerlink" title="类名::实例方法名"></a>类名::实例方法名</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxInt</span> <span class="operator">=</span> list.stream()</span><br><span class="line">                .max(Integer::compareTo)</span><br><span class="line">                .get();</span><br><span class="line">        assertEquals(maxInt, <span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<h2 id="类名-new"><a href="#类名-new" class="headerlink" title="类名::new"></a>类名::new</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">newPerson</span> <span class="operator">=</span> Person.createPerson(Person::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java基础 编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>DispatcherServlet解析</title>
    <url>/blog/2018/09/13/DispatcherServlet%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>有朋友说，你搞了这么久Java，怎么天天写的都是Java基础，现在流行微服务啊～分布式啊～恩。。。主要还是要学习的内容太多了，感觉写个一年半载也写不完，不过为了与时俱进，后面也会偶尔写点这方面的内容，就以SpringCloud全家桶作为主要介绍对象，感兴趣的朋友们快快提前关注啊～～～好了，下面进入正题～<br>在《Tomcat服务器结构浅析（一）》中我们介绍到Web请求在到达Tomcat服务器后，经过一层层容器地查找以及地址的匹配，最后请求被交由Servlet进行处理：<br><img src="/blog/2018/09/13/DispatcherServlet%E8%A7%A3%E6%9E%90/Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86.PNG" alt="Tomcat请求处理"><br>在SpringMVC框架中，占据核心位置的便是DispatcherServlet。在下面的内容中，让我们来看一下，SpringMVC是如何通过DispatcherServlet来处理请求的。</p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Servlet（Server Applet），全称Java Servlet。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。<br>Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。<br>最早支持Servlet标准的是JavaSoft的Java Web Server。此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。<br>一个Web请求的过程如下：</p>
<ol>
<li>WEB服务器接收一个用户请求；</li>
<li>WEB服务器将请求转交给WEB服务器关联的Servlet容器；</li>
<li>Servlet容器找到对应的Servlet并执行这个Servlet；</li>
<li>Servlet容器将处理结果返回给WEB服务器；</li>
<li>WEB服务器把结果送回用户；<br>而在Servlet处理请求的过程当中，又是怎样的一个流程呢？</li>
</ol>
<h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>Servlet的生命（周期）是由容器管理的，换句话说，Servlet程序员不能用代码控制其生命。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>加载和实例化：<br>时机取决于web.xml的定义，如果是比较原始的开发方式（通过配置文件定义Servlet），如果有<load-on-startup>x</load-on-startup>则在容器启动时，反之则在第一次针对这个Servlet的请求发生时。</p>
</li>
<li><p>初始化：<br>实例化后会立马进行初始化。也就是执行init方法。</p>
</li>
<li><p>请求处理：<br>初始化后，Servlet就可以接受请求了。基本方式是执行Servlet接口中的service方法。</p>
</li>
<li><p>终止服务：<br>容器会在合适的时候销毁某个Servlet对象，这个策略取决于容器的开发者&#x2F;商。在容器关闭的时候Servlet对象一定会被销毁。<br>Servlet对象被销毁时，destroy方法会被调用。</p>
</li>
</ol>
<p>当一个请求到达Servlet后，该Servlet的service方法将会得到调用，而具体的业务逻辑，就可以通过该方法来实现了。</p>
<h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><p>接下来，开始讲解今天的主角——<code>DispatcherServlet</code>。首先，还是让我们来看一看，DispatcherServlet的类继承图：<br><img src="/blog/2018/09/13/DispatcherServlet%E8%A7%A3%E6%9E%90/DispatcherServlet%E7%BB%A7%E6%89%BF%E5%9B%BE.PNG" alt="DispatcherServlet继承图"></p>
<h2 id="DispatcherServlet调用链"><a href="#DispatcherServlet调用链" class="headerlink" title="DispatcherServlet调用链"></a>DispatcherServlet调用链</h2><p>Aware类主要是提供了一个能够响应容器各阶段变化的机制，在这里不是我们关注的重点，因此，我们主要来看Servlet部分的继承树。从图中我们可以看到，DispatcherServlet的祖先之一便是Servlet接口。在Servlet生命周期部分，我们提到，请求是通过Servlet的service来进行处理的，可是在DispatcherServlet中，我们并不能找到该函数的定义。其实，service方法是被定义在其父类FrameworkServlet中的，而FrameworkServlet重写了父类HttpServlet的service方法。HttpServlet的service方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">                <span class="comment">// to go through further expensive logic</span></span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">                    <span class="comment">// Invalid date header - proceed as if none was set</span></span><br><span class="line">                    ifModifiedSince = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="number">1000</span> * <span class="number">1000</span>)) &#123;</span><br><span class="line">                    <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                    maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doHead(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">            doPost(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">            doPut(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">            doDelete(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">            doOptions(req,resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">            doTrace(req,resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">            <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">            errArgs[<span class="number">0</span>] = method;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line"></span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其主要是根据请求的不同，将请求交由不同的处理函数来处理。而FrameworkServlet重写的service方法则很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">			<span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">HttpMethod</span> <span class="variable">httpMethod</span> <span class="operator">=</span> HttpMethod.resolve(request.getMethod());</span><br><span class="line">		<span class="keyword">if</span> (HttpMethod.PATCH == httpMethod || httpMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">			processRequest(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">super</span>.service(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>当请求是PATCH请求或者无法获取到请求方法类型时，则直接调用processRequest处理请求，否则，有父类HttpServlet的service来处理，而通过上面我们知道HttpServlet的service主要是根据方法类型，调用了不同的请求处理方法。比如，如果是一个Get请求，则调用的doGet方法，如果是Post请求，则调用的是doPost方法。而这几个方法在FrameworkServlet中被重载，以doGet为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">			<span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		processRequest(request, response);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，请求最终还是交由processRequest函数处理。processRequest是一个final方法，不能被子类重载，在该方法中，调用了doService方法，而DispatcherServlet实现了doService方法，到此，请求最终进入到DispatcherServlet中被消费。在doService中，除了设置请求的属性及一些简单的操作外，主要是调用了doDispatch方法来处理请求的。</p>
<h2 id="DispatcherServlet几个重要成员"><a href="#DispatcherServlet几个重要成员" class="headerlink" title="DispatcherServlet几个重要成员"></a>DispatcherServlet几个重要成员</h2><p>在介绍DispatcherServlet处理请求的流程前，让我们先来认识几个DispatcherServlet类重要的几大组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 文件上传组件</span></span><br><span class="line">   <span class="comment">/** MultipartResolver used by this servlet */</span></span><br><span class="line"><span class="keyword">private</span> MultipartResolver multipartResolver;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 资源定位组件</span></span><br><span class="line"><span class="comment">/** LocaleResolver used by this servlet */</span></span><br><span class="line"><span class="keyword">private</span> LocaleResolver localeResolver;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主题解析组件</span></span><br><span class="line"><span class="comment">/** ThemeResolver used by this servlet */</span></span><br><span class="line"><span class="keyword">private</span> ThemeResolver themeResolver;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理器映射器组件集合</span></span><br><span class="line"><span class="comment">/** List of HandlerMappings used by this servlet */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理器适配器组件集合</span></span><br><span class="line"><span class="comment">/** List of HandlerAdapters used by this servlet */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 异常处理解析器集合</span></span><br><span class="line"><span class="comment">/** List of HandlerExceptionResolvers used by this servlet */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 视图名解析器</span></span><br><span class="line"><span class="comment">/** RequestToViewNameTranslator used by this servlet */</span></span><br><span class="line"><span class="keyword">private</span> RequestToViewNameTranslator viewNameTranslator;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重定向及FlashMap存储组件</span></span><br><span class="line"><span class="comment">/** FlashMapManager used by this servlet */</span></span><br><span class="line"><span class="keyword">private</span> FlashMapManager flashMapManager;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 视图解析组件集合</span></span><br><span class="line"><span class="comment">/** List of ViewResolvers used by this servlet */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ViewResolver&gt; viewResolvers;</span><br></pre></td></tr></table></figure>

<p>SpringMVC定义了一套默认的组件实现类，也就是说，即使在Spring容器中没有显示定义组件，DisoatcherServlet也会装配好一套可用的默认组件，在org&#x2F;springframework&#x2F;web&#x2F;servlet类路径下有一个DispatcherServlet.properties配置文件，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Default implementation classes <span class="keyword">for</span> DispatcherServlet<span class="string">&#x27;s strategy interfaces.</span></span><br><span class="line"><span class="string"># Used as fallback when no matching beans are found in the DispatcherServlet context.</span></span><br><span class="line"><span class="string"># Not meant to be customized by application developers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span></span><br><span class="line"><span class="string">	org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span></span><br><span class="line"><span class="string">	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span></span><br><span class="line"><span class="string">	org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\</span></span><br><span class="line"><span class="string">	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span></span><br><span class="line"><span class="string">	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</span></span><br></pre></td></tr></table></figure>
<p>如果我们希望采用非默认类型的组件，则只需要在Spring配置文件中配置自定义的组件Bean即可。SpringMVC一旦发现上下文中有用户自定义的组件，就不会使用默认的组件了。</p>
<h2 id="doDispatch方法"><a href="#doDispatch方法" class="headerlink" title="doDispatch方法"></a>doDispatch方法</h2><p>接下来，我们来看下doDispatch方法是如何处理一个Web请求的。首先是一个处理路径图：<br><img src="/blog/2018/09/13/DispatcherServlet%E8%A7%A3%E6%9E%90/DispatcherServlet%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt="DispatcherServlet请求处理流程"><br>下面，让我们以上面的图为参照，来解析一下doDispatch函数的处理逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">		<span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取异步请求处理管理器，当业务逻辑复杂（或者其他原因），为了避免请求线程阻塞，需要委托给另一个线程的时候会使用该处理器来处理请求</span></span><br><span class="line">		<span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 检查是否为文件上传请求，如果是的话则将request包装为一个MultipartHttpServletRequest（继承自HttpServletRequest）请求</span></span><br><span class="line">				processedRequest = checkMultipart(request);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//若与原始请求不同，说明是一个文件上传请求，否则为一个普通的请求</span></span><br><span class="line">				multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据请求，获取处理器请求执行链，否则该请求不能被应用处理</span></span><br><span class="line">				<span class="comment">// Determine handler for the current request.</span></span><br><span class="line">				mappedHandler = getHandler(processedRequest);</span><br><span class="line">				<span class="keyword">if</span> (mappedHandler == <span class="literal">null</span> || mappedHandler.getHandler() == <span class="literal">null</span>) &#123;</span><br><span class="line">					noHandlerFound(processedRequest, response);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取处理器适配器</span></span><br><span class="line">				<span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">				<span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果是GET或者HEAD请求，调用HandlerAdapter.getLastModified方法看看目标Controller方法在对于该请求有没有可用的lastModified逻辑，如果有的话就使用ServletWebRequest.checkNotModified逻辑判断当前lastModfied值和http header的上次缓存值，如果还没有过期就设置304头并且返回并结束整个请求流程。否则继续。</span></span><br><span class="line">				<span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">				<span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">				<span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">					<span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">&quot;Last-Modified value for [&quot;</span> + getRequestUri(request) + <span class="string">&quot;] is: &quot;</span> + lastModified);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理请求前，先调用处理器执行链前置方法，内部主要是调用了拦截器的前置方法</span></span><br><span class="line">				<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用处理器适配器来处理请求并返回模型视图对象</span></span><br><span class="line">				<span class="comment">// Actually invoke the handler.</span></span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查异步处理是否已经开始了，如果开始了则目前的线程不再继续处理该请求，直接返回</span></span><br><span class="line">				<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果模型视图对象不为null且存在视图，则设置该视图的名字</span></span><br><span class="line">				applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理请求后，调用处理器执行链后置方法，内部主要是调用了拦截器的后置方法</span></span><br><span class="line">				mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				dispatchException = ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">				<span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">				<span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">				dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理请求分发处理结果，如处理异常，解析视图内容等</span></span><br><span class="line">			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果异步请求处理管理器已开始处理该请求，则调用处理器执行链的回调函数，其内部主要是调用了AsyncHandlerInterceptor类型的拦截器</span></span><br><span class="line">			<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				<span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">				<span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">					mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//关闭由于文件上传请求导致的打开的资源</span></span><br><span class="line">				<span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">				<span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">					cleanupMultipart(processedRequest);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在多数的场景到中，我们编写控制器，使用@RestController注解对控制器进行注解，使用@GetMapping注解标注函数，dispatcherServlet的重点，就在如何将请求分发到具体的Controller中的方法中。<br>通过上面源码的讲解可以看出，其重点就在于通过请求获取处理器执行链HandlerExecutionChain（其内部主要是对处理该请求的对象方法的封装及处理器拦截器的包装）及处理器适配器HandlerAdapter。接下来我们看下获取处理器执行链HandlerExecutionChain的getHandler方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">for</span> (HandlerMapping hm : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(</span><br><span class="line">						<span class="string">&quot;Testing handler map [&quot;</span> + hm + <span class="string">&quot;] in DispatcherServlet with name &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> hm.getHandler(request);</span><br><span class="line">			<span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> handler;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其主要的逻辑是通过处理器映射器来解析请求，并返回正确的HandlerExecutionChain,HandlerMapping接口如下：<br><img src="/blog/2018/09/13/DispatcherServlet%E8%A7%A3%E6%9E%90/HandlerMapping%E7%BB%A7%E6%89%BF%E5%9B%BE.PNG" alt="HandlerMapping继承图"><br>上述的几个实现类通过不同的策略，将请求的路径映射到对应的处理器上。当我们访问由@RestController标注的类下的接口时（此处以ConfigController下的list接口为例），其最终便是由RequestMappingHandlerMapping解析的出了HandlerExecutionChain，通过断点可以看到：<br><img src="/blog/2018/09/13/DispatcherServlet%E8%A7%A3%E6%9E%90/HandlerExecutionChain%E7%BB%93%E6%9E%84.png" alt="HandlerExecutionChain结构"><br>该处理器执行链中已经包含了处理该请求的接口的一些信息，后续的工作便是使用该接口处理请求。而这些工作都是通过处理器适配器HandlerAdapter来完成。接下来看一下HandlerAdapter的继承图：<br><img src="/blog/2018/09/13/DispatcherServlet%E8%A7%A3%E6%9E%90/HandlerAdapter%E7%BB%A7%E6%89%BF%E5%9B%BE.PNG" alt="DispatcherServlet请求处理流程"><br>上述请求获取到的处理器对应的适配器便是RequestMappingHandlerAdapter<br><img src="/blog/2018/09/13/DispatcherServlet%E8%A7%A3%E6%9E%90/%E8%8E%B7%E5%8F%96HandlerAdapter.PNG" alt="获取HandlerAdapter"><br>之后，便是执行HandlerExecutionChain中拦截器的前置方法，通过适配器执行处理器对请求的处理过程并返回模型视图对象，再执行HandlerExecutionChain中拦截器的后置方法。最后，便是根据处理器对请求的处理情况，对结果进行最终的解析，方法processDispatchResult：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Handle the result of handler selection and handler invocation, which is</span></span><br><span class="line"><span class="comment">	 * either a ModelAndView or an Exception to be resolved to a ModelAndView.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">			HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">				mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> (mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>);</span><br><span class="line">				mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">				errorView = (mv != <span class="literal">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">		<span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">			render(mv, request, response);</span><br><span class="line">			<span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">				WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Null ModelAndView returned to DispatcherServlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">						<span class="string">&quot;&#x27;: assuming HandlerAdapter completed request handling&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">			mappedHandler.triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>从注释中可以看出，该方法便是根据处理器处理结果是抛出异常还是返回模型视图对象，对结果进一步做了处理。若处理器返回了模型视图对象，对视图的渲染，便是在该函数中通过调用render函数来完成的。由于对标注了@RestController的控制器，其返回的模型视图对象是null，故不会进行渲染，在这里也就不再将视图渲染的内容展开来讲了。</p>
<p>至此，DispatcherServlet主要的工作大致就分析完了。想要自己一探究竟的朋友，可以自己写一个小接口，通过断点走一边流程，相信会对DispatcherServlet有更深入的理解～～</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud简介</title>
    <url>/blog/2018/10/14/SpringCloud%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>现在去看很多公司的招聘信息，都会发现越来越多的公司都有对SpringCloud的要求，自己目前所在公司的一部分业务也是建立在Spring Cloud上的。今天开始，将单独开设一个SpringCloud主题，讲解Spring Cloud的使用。<br>在使用了一段时间的SpringBoot之后，我们会想，如果说SpringBoot的思想是将大型的Web服务拆分为低耦合、高内聚的微服务的话，当拆分出来的微服务较多后，如果来（分布式环境或非分布式环境）有效地管理这些微服务，以及各微服务如何与其他微服务进行交互便成了问题。如果是最原始的方案，当某一个微服务需要调用其他微服务的时候，需要知道其他微服务的地址信息，以及接口信息。但是当系统内部的微服务关系错综复杂时，难道一个微服务的地址更改之后，需要修改并重新其他相关联的服务吗？这样的管理方式便不再合适。而Spring Cloud从技术架构上降低了对大型系统构建的要求，使我们以非常低的成本（技术或者硬件）搭建一套高效、分布式、容错的平台。</p>
<h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。<br><img src="/blog/2018/10/14/SpringCloud%E7%AE%80%E4%BB%8B/SpringCloud%E6%9E%B6%E6%9E%84.png" alt="SpringCloud架构"><br>当一个Web请求到来时，系统内部的调用过程如下：</p>
<ol>
<li>外部或者内部的非Spring Cloud项目都统一通过API网关（Zuul）来访问内部服务.</li>
<li>网关接收到请求后，从注册中心（Eureka）获取可用服务</li>
<li>由Ribbon进行均衡负载后，分发到后端的具体实例</li>
<li>微服务之间通过Feign进行通信处理业务</li>
<li>Hystrix负责处理服务超时熔断</li>
<li>Turbine监控服务间的调用和熔断相关指标</li>
</ol>
<p>在上图中可以看到，整个系统是由许多微服务组成的。微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，Spring Cloud就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，Spring Cloud做为大管家需要管理好这些微服务，自然需要很多小弟来帮忙。如上图中出现的Spring Cloud Config、Spring Cloud Sleuth、Spring Cloud Eureka、Spring Cloud Zuul、Spring Cloud Hystrix等等以外，还包含且不限于Spring Cloud Bus、Spring Cloud for Cloud Foundry、Spring Cloud Cluster、Spring Cloud Consul、Spring Cloud Security、Spring Cloud Data Flow、Spring Cloud Stream、Spring Cloud Task、Spring Cloud Zookeeper、Spring Cloud Connectors、Spring Cloud Starters、Spring Cloud CLI。每一个微服务都有其独一无二的作用。</p>
<h2 id="Spring-Cloud-与-Spring-Boot"><a href="#Spring-Cloud-与-Spring-Boot" class="headerlink" title="Spring Cloud 与 Spring Boot"></a>Spring Cloud 与 Spring Boot</h2><p>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的云应用开发工具；Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，可以不基于Spring Boot吗？不可以。</p>
<p>Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。</p>
<h2 id="Spring-Cloud的优势"><a href="#Spring-Cloud的优势" class="headerlink" title="Spring Cloud的优势"></a>Spring Cloud的优势</h2><p>微服务的框架那么多比如：dubbo、Kubernetes，为什么就要使用Spring Cloud的呢？</p>
<ul>
<li>产出于spring大家族，spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善。</li>
<li>有Spring Boot 这个独立干将可以省很多事，大大小小的活Spring Boot都搞的挺不错。</li>
<li>作为一个微服务治理的大家伙，考虑的很全面，几乎服务治理的方方面面都考虑到了，方便开发开箱即用。</li>
<li>Spring Cloud 活跃度很高，教程很丰富，遇到问题很容易找到解决方案</li>
<li>轻轻松松几行代码就完成了熔断、均衡负载、服务中心的各种平台功能<br>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，我目前所在的公司很多服务就是建立在微服务及容器云上的，这极大地方便了我们开发人员的开发效率，同时也减轻了运维人员的工作。</li>
</ul>
<p>网上关于个Spring Cloud微服务组件的文章及书籍很多，但是很多知识只是停留在如何使用的阶段。在后面的文章当中，我将在讲解Spring Cloud各微服务功能的同时，深入去解析器内部原理，以达到知其然而知其所以然的目的。作为一个爱钻牛角尖的程序员，这也是我为什么还要写这个系列的原因。</p>
<p>欢迎关注个人公众号：<br><img src="/blog/images/%E4%B8%AA%E4%BA%BA%E5%85%AC%E5%8F%B7.jpg" alt="个人公号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring SpringCloud</tag>
      </tags>
  </entry>
</search>
